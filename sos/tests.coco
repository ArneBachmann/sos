import builtins, logging, os, shutil, sys, time, traceback, unittest
StringIO = (__import__("StringIO" if sys.version_info.major < 3 else "io")).StringIO  # enables import via ternary expression
try: from unittest import mock  # Py3
except: import mock  # installed via pip
try: from typing import Any, List, Union  # only required for mypy
except: pass

testFolder = os.path.abspath(os.path.join(os.getcwd(), "test"))
try:
  import configr  # optional dependency
  os.environ["TEST"] = testFolder  # needed to mock configr library calls in sos
except: configr = None  # declare as undefined
import sos
sos.defaults["defaultbranch"] = "trunk"  # because sos.main() is never called


def debugTestRunner(post_mortem = None) =
  ''' Unittest runner doing post mortem debugging on failing tests. '''
  import pdb
  if post_mortem is None: post_mortem = pdb.post_mortem
  class DebugTestResult(unittest.TextTestResult):
    def addError(self, test, err):  # called before tearDown()
      traceback.print_exception(*err)
      post_mortem(err[2])
      super(DebugTestResult, self).addError(test, err)
    def addFailure(self, test, err):
      traceback.print_exception(*err)
      post_mortem(err[2])
      super(DebugTestResult, self).addFailure(test, err)
  unittest.TextTestRunner(resultclass = DebugTestResult)

def branchFolder(branch:int, revision:int) -> str = "." + os.sep + sos.metaFolder + os.sep + "b%d" % branch + os.sep + "r%d" % revision

def wrapChannels(func: -> Any) =
  ''' Wrap function call to capture and return strings emitted on stdout and stderr. '''
  oldv, oldo, olde = sys.argv, sys.stdout, sys.stderr
  buf = StringIO()
  sys.stdout = sys.stderr = buf
  handler = logging.StreamHandler(buf)
  logging.getLogger().addHandler(handler)
  try: func()  # capture output into buf
  except Exception as E: buf.write(str(E) + "\n"); traceback.print_exc(file = buf)
  logging.getLogger().removeHandler(handler)
  sys.argv, sys.stdout, sys.stderr = oldv, oldo, olde
  buf.getvalue()

def mockInput(datas:str[], func) -> Any:
  with mock.patch("builtins.input" if sys.version_info.major >= 3 else "utility._coconut_raw_input", side_effect = datas): return func()


class Tests(unittest.TestCase):
  ''' Entire test suite. '''

  def setUp(_):
    for entry in os.listdir(testFolder):  # cannot remove testFolder on Windows when using TortoiseSVN as VCS
      resource = os.path.join(testFolder, entry)
      try: os.unlink(resource)
      except: shutil.rmtree(resource)
    os.chdir(testFolder)

  def tearDown(_): pass

  def assertAllIn(_, what:str[], where:Union[str,List[str]]) -> None: [_.assertIn(w, where) for w in what]

  def assertInAll(_, what:str, where:str[]) -> None: [_.assertIn(what, w) for w in where]

  def assertInAny(_, what:str, where:str[]) -> None: _.assertTrue(any(what in w for w in where))

  def assertNotInAny(_, what:str, where:str[]) -> None: _.assertFalse(any(what in w for w in where))

  def createFile(_, number:Union[int,str], contents:str = "x" * 10, prefix:str? = None) -> None:
    with open(("." if prefix is None else prefix) + os.sep + (("file%d" % number) if isinstance(number, int) else number), "wb") as fd: fd.write(contents if isinstance(contents, bytes) else contents.encode("cp1252"))

  def existsFile(_, number:int, expectedContents:str = None) -> bool:
    if not os.path.exists("." + os.sep + "file%d" % number): return False
    if expectedContents is None: return True
    with open("." + os.sep + "file%d" % number, "wb") as fd: return fd.read() == expectedContents

  def testAccessor(_):
     a = sos.Accessor({"a": 1})
     _.assertEqual((1, 1), (a["a"], a.a))

  def testFirstofmap(_):
    _.assertEqual(2, sos.firstOfMap({"a": 1, "b": 2}, ["x", "b"]))
    _.assertIsNone(sos.firstOfMap({"a": 1, "b": 2}, []))

  def testAjoin(_):
    _.assertEqual("a1a2", sos.ajoin("a", ["1", "2"]))
    _.assertEqual("* a\n* b", sos.ajoin("* ", ["a", "b"], "\n"))

  def testFindChanges(_):
    m = sos.Metadata(os.getcwd())
    m.loadBranches()
    _.createFile(1, "1")
    m.createBranch(0)
    _.assertEqual(1, len(m.paths))
    time.sleep(1.1)  # time required by filesystem time resolution issues
    _.createFile(1, "2")
    _.createFile(2, "2")
    changes = m.findChanges()  # detect time skew
    _.assertEqual(1, len(changes.additions))
    _.assertEqual(0, len(changes.deletions))
    _.assertEqual(1, len(changes.modifications))
    m.integrateChangeset(changes)
    _.createFile(2, "12")  # modify file
    changes = m.findChanges(0, 1)  # by size, creating new commit
    _.assertEqual(0, len(changes.additions))
    _.assertEqual(0, len(changes.deletions))
    _.assertEqual(1, len(changes.modifications))
    _.assertTrue(os.path.exists(branchFolder(0, 1)))
    _.assertTrue(os.path.exists(branchFolder(0, 1) + os.sep + "03b69bc801ae11f1ff2a71a50f165996d0ad681b4f822df13329a27e53f0fcd2"))

  def testDiffFunc(_):
    a = {"./a": sos.PathInfo("", 0, 0, "")}
    b = {"./a": sos.PathInfo("", 0, 0, "")}
    changes = sos.diffPathSets(a, b)
    _.assertEqual(0, len(changes.additions))
    _.assertEqual(0, len(changes.deletions))
    _.assertEqual(0, len(changes.modifications))
    b = {"./a": sos.PathInfo("", 1, 0, "")}
    changes = sos.diffPathSets(a, b)
    _.assertEqual(0, len(changes.additions))
    _.assertEqual(0, len(changes.deletions))
    _.assertEqual(1, len(changes.modifications))
    b = {}  # diff contains no entries -> no change
    changes = sos.diffPathSets(a, b)
    _.assertEqual(0, len(changes.additions))
    _.assertEqual(0, len(changes.deletions))
    _.assertEqual(0, len(changes.modifications))
    b = {"./a": sos.PathInfo("", None, 1, "")}  # in diff marked as deleted
    changes = sos.diffPathSets(a, b)
    _.assertEqual(0, len(changes.additions))
    _.assertEqual(1, len(changes.deletions))
    _.assertEqual(0, len(changes.modifications))
    b = {"./b": sos.PathInfo("", 1, 1, "")}
    changes = sos.diffPathSets(a, b)
    _.assertEqual(1, len(changes.additions))
    _.assertEqual(0, len(changes.deletions))
    _.assertEqual(0, len(changes.modifications))
    a = {"./a": sos.PathInfo("", None, 0, "")}  # mark as deleted
    b = {"./a": sos.PathInfo("", 1, 0, "")}  # re-added
    changes = sos.diffPathSets(a, b)
    _.assertEqual(1, len(changes.additions))
    _.assertEqual(0, len(changes.deletions))
    _.assertEqual(0, len(changes.modifications))
    changes = sos.diffPathSets(b, a)
    _.assertEqual(0, len(changes.additions))
    _.assertEqual(1, len(changes.deletions))
    _.assertEqual(0, len(changes.modifications))

  def testPatternPaths(_):
    sos.offline(options = ["--track"])
    os.mkdir("sub")
    _.createFile("sub" + os.sep + "file1", "sdfsdf")
    sos.add("./sub", "file?")  # this doesn't work as direct call won't invoke getRoot and therefore won't chdir virtually into that folder
    sos.commit("test")
    _.assertEqual(2, len(os.listdir(os.path.join(sos.metaFolder, "b0", "r1"))))  # sub/file1 was added
    _.createFile(1)
    try: sos.commit("nothing"); _.fail()  # should not commit anything, as the file in base folder doesn't match the path pattern
    except: pass

  def testComputeSequentialPathSet(_):
    os.makedirs(branchFolder(0, 0))
    os.makedirs(branchFolder(0, 1))
    os.makedirs(branchFolder(0, 2))
    os.makedirs(branchFolder(0, 3))
    os.makedirs(branchFolder(0, 4))
    m = sos.Metadata(os.getcwd())
    m.branch = 0
    m.commit = 2
    m.saveBranches()
    m.paths = {"./a": sos.PathInfo("", 0, 0, "")}
    m.saveCommit(0, 0)  # initial
    m.paths["./a"] = sos.PathInfo("", 1, 0, "")
    m.saveCommit(0, 1)  # mod
    m.paths["./b"] = sos.PathInfo("", 0, 0, "")
    m.saveCommit(0, 2)  # add
    m.paths["./a"] = sos.PathInfo("", None, 0, "")
    m.saveCommit(0, 3)  # del
    m.paths["./a"] = sos.PathInfo("", None, 0, "")
    m.saveCommit(0, 4)  # readd
    m.commits = {i: sos.CommitInfo(i, 0, None) for i in range(5)}
    m.saveBranch(0)
    m.computeSequentialPathSet(0, 4)
    _.assertEqual(2, len(m.paths))

  def testParseRevisionString(_):
    m = sos.Metadata(os.getcwd())
    m.branch = 1
    m.commits = {0: 0, 1:1, 2:2}
    _.assertEqual((1, 3), m.parseRevisionString("3"))
    _.assertEqual((2, 3), m.parseRevisionString("2/3"))
    _.assertEqual((1, -1), m.parseRevisionString(None))
    _.assertEqual((2, -1), m.parseRevisionString("2/"))
    _.assertEqual((1, -2), m.parseRevisionString("/-2"))

  def testOfflineEmpty(_):
    os.mkdir("." + os.sep + sos.metaFolder)
    try: sos.offline("trunk"); _.fail()
    except SystemExit: pass
    os.rmdir("." + os.sep + sos.metaFolder)
    sos.offline("test")
    _.assertIn(sos.metaFolder, os.listdir("."))
    _.assertAllIn(["b0", sos.metaFile], os.listdir("." + os.sep + sos.metaFolder))
    _.assertAllIn(["r0", sos.metaFile], os.listdir("." + os.sep + sos.metaFolder + os.sep + "b0"))
    _.assertEqual(2, len(os.listdir("." + os.sep + sos.metaFolder)))  # only branch folder and meta data file
    _.assertEqual(2, len(os.listdir("." + os.sep + sos.metaFolder + os.sep + "b0")))  # only commit folder and meta data file
    _.assertEqual(1, len(os.listdir(branchFolder(0, 0))))  # only meta data file

  def testOfflineWithFiles(_):
    _.createFile(1, "x" * 100)
    _.createFile(2)
    sos.offline("test")
    _.assertAllIn(["file1", "file2", sos.metaFolder], os.listdir("."))
    _.assertAllIn(["b0", sos.metaFile], os.listdir("." + os.sep + sos.metaFolder))
    _.assertAllIn(["r0", sos.metaFile], os.listdir("." + os.sep + sos.metaFolder + os.sep + "b0"))
    _.assertAllIn([sos.metaFile, "03b69bc801ae11f1ff2a71a50f165996d0ad681b4f822df13329a27e53f0fcd2", "b9ee10a87f612e299a6eb208210bc0898092a64c48091327cc2aaeee9b764ffa"], os.listdir("." + os.sep + sos.metaFolder + os.sep + "b0" + os.sep + "r0"))
    _.assertEqual(2, len(os.listdir("." + os.sep + sos.metaFolder)))  # only branch folder and meta data file
    _.assertEqual(2, len(os.listdir("." + os.sep + sos.metaFolder + os.sep + "b0")))  # only commit folder and meta data file
    _.assertEqual(3, len(os.listdir(branchFolder(0, 0))))  # only meta data file plus branch base file copies

  def testBranch(_):
    _.createFile(1, "x" * 100)
    _.createFile(2)
    sos.offline("test")  # b0/r0
    sos.branch("other")  # b1/r0
    _.assertAllIn(["b0", "b1", sos.metaFile], os.listdir("." + os.sep + sos.metaFolder))
    _.assertEqual(list(sorted(os.listdir("." + os.sep + sos.metaFolder + os.sep + "b0"))),
                  list(sorted(os.listdir("." + os.sep + sos.metaFolder + os.sep + "b1"))))
    _.assertEqual(list(sorted(os.listdir(branchFolder(0, 0)))),
                  list(sorted(os.listdir(branchFolder(1, 0)))))
    _.createFile(1, "z")  # modify file
    sos.branch()  # b2/r0  branch to unnamed branch with modified file tree contents
    _.assertNotEqual(os.stat("." + os.sep + sos.metaFolder + os.sep + "b1" + os.sep + "r0" + os.sep + "b9ee10a87f612e299a6eb208210bc0898092a64c48091327cc2aaeee9b764ffa").st_size,
                     os.stat("." + os.sep + sos.metaFolder + os.sep + "b2" + os.sep + "r0" + os.sep + "b9ee10a87f612e299a6eb208210bc0898092a64c48091327cc2aaeee9b764ffa").st_size)
    _.createFile(3, "z")
    sos.branch("from_last_revision", ["--last", "--stay"])  # b3/r0 create copy of other file1,file2 and don't switch
    _.assertEqual(list(sorted(os.listdir("." + os.sep + sos.metaFolder + os.sep + "b3" + os.sep + "r0"))),
                  list(sorted(os.listdir("." + os.sep + sos.metaFolder + os.sep + "b2" + os.sep + "r0"))))
    # Check sos.status output which branch is marked


  def testComittingAndChanges(_):
    _.createFile(1, "x" * 100)
    _.createFile(2)
    sos.offline("test")
    changes = sos.changes()
    _.assertEqual(0, len(changes.additions))
    _.assertEqual(0, len(changes.deletions))
    _.assertEqual(0, len(changes.modifications))
    _.createFile(1, "z")
    changes = sos.changes()
    _.assertEqual(0, len(changes.additions))
    _.assertEqual(0, len(changes.deletions))
    _.assertEqual(1, len(changes.modifications))
    sos.commit("message")
    _.assertAllIn(["r0", "r1", sos.metaFile], os.listdir("." + os.sep + sos.metaFolder + os.sep + "b0"))
    _.assertAllIn([sos.metaFile, "b9ee10a87f612e299a6eb208210bc0898092a64c48091327cc2aaeee9b764ffa"], os.listdir(branchFolder(0, 1)))
    _.assertEqual(2, len(os.listdir(branchFolder(0, 1))))  # no further files, only the modified one
    _.assertEqual(1, len(sos.changes("/0").modifications))  # vs. implicit (same) branch revision
    _.assertEqual(1, len(sos.changes("0/0").modifications))  # vs. explicit branch revision
    _.createFile(1, "")  # create empty file, mentioned in meta data, but not stored as own file
    _.assertEqual(0, len(changes.additions))
    _.assertEqual(0, len(changes.deletions))
    _.assertEqual(1, len(changes.modifications))
    sos.commit("modified")
    _.assertEqual(1, len(os.listdir(branchFolder(0, 2))))  # no further files, only the modified one
    try: sos.commit("nothing"); _.fail()  # expecting Exit due to no changes
    except: pass

  def testSwitch(_):
    _.createFile(1, "x" * 100)
    _.createFile(2, "y")
    sos.offline("test")  # file1-2  in initial branch commit
    sos.branch("second")  # file1-2  switch, having same files
    sos.switch("0")  # no change  switch back, no problem
    sos.switch("second")  # no change  # switch back, no problem
    _.createFile(3, "y")  # generate a file
    try: sos.switch("test"); _.fail()  # uncommited changes detected
    except SystemExit: pass
    sos.commit("Finish")  # file1-3  commit third file into branch second
    sos.changes()
    sos.switch("test")  # file1-2, remove file3 from file tree
    _.assertFalse(_.existsFile(3))  # removed when switching back to test
    out = wrapChannels(() -> sos.status()).replace("\r", "")
    _.assertIn("  * b0   'test'", out)  # TODO dirty/insync
    _.assertIn("    b1 'second'", out)  # TODO dirty/insync
    _.createFile(4, "xy")  # generate a file
    sos.switch("second", "--force")  # avoids warning on uncommited changes, but keeps file4
    _.assertFalse(_.existsFile(4))  # removed when forcedly switching back to test
    _.assertTrue(_.existsFile(3))  # was restored from branch's revision r1
    os.unlink("." + os.sep + "file1")  # remove old file1
    sos.switch("test", "--force")  # should restore file1 and remove file3
    _.assertTrue(_.existsFile(1))  # was restored from branch's revision r1
    _.assertFalse(_.existsFile(3))  # was restored from branch's revision r1

  def testAutoDetectVCS(_):
    os.mkdir(".git")
    sos.offline(sos.vcsBranches[sos.findSosVcsBase()[2]])  # create initial branch
    with open(sos.metaFolder + os.sep + sos.metaFile, "r") as fd: meta = fd.read()
    _.assertTrue("\"master\"" in meta)
    os.rmdir(".git")

  def testUpdate(_):
    sos.offline("trunk")  # create initial branch b0/r0
    _.createFile(1, "x" * 100)
    sos.commit("second")  # create b0/r1

    sos.switch("/0")  # go back to b0/r0 - deletes file1
    _.assertFalse(_.existsFile(1))

    sos.update("/1")  # recreate file1
    _.assertTrue(_.existsFile(1))

    sos.commit("third", ["--force"])  # force because nothing to commit. should create r2 with same contents as r1, but as differential from r1, not from r0 (= no changes in meta folder)
    _.assertTrue(os.path.exists(branchFolder(0, 2)))
    _.assertTrue(os.path.exists(branchFolder(0, 2) + os.sep + sos.metaFile))
    _.assertEqual(1, len(os.listdir(branchFolder(0, 2))))  # only meta data file, no differential files

    sos.update("/1")  # do nothing, as nothing has changed
    _.assertTrue(_.existsFile(1))

    _.createFile(2, "y" * 100)
#    out = wrapChannels(() -> sos.branch("other"))  # won't comply as there are changes
#    _.assertIn("--force", out)
    sos.branch("other", ["--force"])  # automatically including file 2 (as we are in simple mode)
    _.assertTrue(_.existsFile(2))
    sos.update("trunk", ["--add"])  # only add stuff
    _.assertTrue(_.existsFile(2))
    sos.update("trunk")  # nothing to do
    _.assertFalse(_.existsFile(2))  # removes file not present in original branch

    theirs = b"a\nb\nc\nd\ne\nf\ng\nh\nx\nx\nj\nk"
    _.createFile(10, theirs)
    mine = b"a\nc\nd\ne\ng\nf\nx\nh\ny\ny\nj"  # missing "b", inserted g, modified g->x, replace x/x -> y/y, removed k
    _.createFile(11, mine)
    _.assertEqual(b"a\nb\nc\nd\ne\nf\ng\nh\nx\nx\nj\nk",    sos.merge(filename = "." + os.sep + "file10", intoname = "." + os.sep + "file11", mergeOperation = sos.MergeOperation.BOTH, conflictResolution = sos.ConflictResolution.THEIRS))  # completely recreated other file
    _.assertEqual(b"a\nb\nc\nd\ne\ng\nf\ng\nx\nh\nx\nx\ny\ny\nj\nk", sos.merge(filename = "." + os.sep + "file10", intoname = "." + os.sep + "file11", mergeOperation = sos.MergeOperation.INSERT, conflictResolution = sos.ConflictResolution.MINE))

  def testUpdate2(_):
    _.createFile("test.txt", "x" * 10)
    sos.offline("trunk", ["--strict"])  # use strict mode, as timestamp differences are too small for testing
    sos.branch("mod")
    _.createFile("test.txt", "x" * 5 + "y" * 5)
    time.sleep(1.1)
    sos.commit("mod")  # create b0/r1
    sos.switch("trunk", ["--force"])  # should replace contents, force in case some other files were modified (e.g. during working on the code) TODO investigate more
    with open("test.txt", "rb") as fd: _.assertEqual(b"x" * 10, fd.read())
    sos.update("mod", ["--theirs"])  # integrate changes TODO same with ask -> theirs
    with open("test.txt", "rb") as fd: _.assertEqual(b"x" * 5 + b"y" * 5, fd.read())
    _.createFile("test.txt", "x" * 10)
    mockInput(["t"], () -> sos.update("mod", ["--ask"]))  # same as above with interaction -> theirs
    with open("test.txt", "rb") as fd: _.assertEqual(b"x" * 5 + b"y" * 5, fd.read())

  def testEolDet(_):
    _.assertEqual(b"\n", sos.eoldet(b"a\nb"))
    _.assertEqual(b"\r\n", sos.eoldet(b"a\r\nb\r\n"))
    _.assertEqual(b"\r", sos.eoldet(b"\ra\rb"))
    _.assertAllIn(["Inconsistent", "with "], wrapChannels(() -> _.assertEqual(b"\n", sos.eoldet(b"\r\na\r\nb\n"))))
    _.assertAllIn(["Inconsistent", "without"], wrapChannels(() -> _.assertEqual(b"\n", sos.eoldet(b"\ra\nnb\n"))))
    _.assertIsNone(sos.eoldet(b""))
    _.assertIsNone(sos.eoldet(b"sdf"))

  def testMerge(_):
    a = b"a\nb\ncc\nd"
    b = b"a\nb\nee\nd"
    _.assertEqual(b"a\nb\ncc\nee\nd", sos.merge(a, b, mergeOperation = sos.MergeOperation.INSERT))  # means insert changes from a into b, but don't replace
    _.assertEqual(b"a\nb\nd",         sos.merge(a, b, mergeOperation = sos.MergeOperation.REMOVE))
    _.assertEqual(b"a\nb\ncc\nd",     sos.merge(a, b, mergeOperation = sos.MergeOperation.BOTH))
    # Now test intra-line merging without conflicts
    _.assertEqual(b"a\nbc d\ne", sos.merge(b"a\nbc d\ne", b"a\nbcd\ne", mergeOperation = sos.MergeOperation.INSERT))  # because it's a deletion ['  a', '- bc d', '?   -\n', '+ bcd', '  e']
    _.assertEqual(b"a\nbcd\ne",  sos.merge(b"a\nbc d\ne", b"a\nbcd\ne", mergeOperation = sos.MergeOperation.REMOVE))  # ['  a', '- bc d', '?   -\n', '+ bcd', '  e']
    _.assertEqual(b"a\nbc d\ne", sos.merge(b"a\nbcd\ne", b"a\nbc d\ne", mergeOperation = sos.MergeOperation.INSERT))  # nothing to insert
    _.assertEqual(b"a\nbcd\ne",  sos.merge(b"a\nbcd\ne", b"a\nbc d\ne", mergeOperation = sos.MergeOperation.REMOVE))  # remove space
    # Test with change + insert (conflict)
    _.assertEqual(b"a\nb fdd d\ne", sos.merge(b"a\nb cd d\ne", b"a\nb fdd d\ne", conflictResolution = sos.ConflictResolution.MINE))
    _.assertEqual(b"a\nb cd d\ne",  sos.merge(b"a\nb cd d\ne", b"a\nb fdd d\ne", conflictResolution = sos.ConflictResolution.THEIRS))  # ['  a', '- b cd d', '?   ^\n', '+ b fdd d', '?   ^^\n', '  e']
    _.assertEqual(b"a\nb fdd d\ne", mockInput(["i"], () -> sos.merge(b"a\nb cd d\ne", b"a\nb fdd d\ne", conflictResolution = sos.ConflictResolution.ASK)))  # ['  a', '- b cd d', '?   ^\n', '+ b fdd d', '?   ^^\n', '  e']
    _.assertEqual(b"a\nb cd d\ne",  mockInput(["t"], () -> sos.merge(b"a\nb cd d\ne", b"a\nb fdd d\ne", conflictResolution = sos.ConflictResolution.ASK)))  # ['  a', '- b cd d', '?   ^\n', '+ b fdd d', '?   ^^\n', '  e']
    _.assertEqual(b"abbc", sos.merge(b"abbc", b"addc", mergeOperation = sos.MergeOperation.BOTH, conflictResolution = sos.ConflictResolution.THEIRS))
    _.assertEqual(b"a\nbb\nc", sos.merge(b"a\nbb\nc", b"a\ndd\nc", mergeOperation = sos.MergeOperation.BOTH, conflictResolution = sos.ConflictResolution.THEIRS))
    _.assertIn("Differing EOL-styles", wrapChannels(() -> sos.merge(b"a\nb", b"a\r\nb")))  # expect warning
    _.assertIn(b"a\r\nb", sos.merge(b"a\nb", b"a\r\nb"))  # in doubt, use "mine" CR-LF

  def testPickyMode(_):
    sos.offline("trunk", ["--picky"])
    sos.add(".", "file?", ["--force"])
    _.createFile(1, "aa")
    sos.commit("First")  # add one file
    _.assertEqual(2, len(os.listdir(branchFolder(0, 1))))
    _.createFile(2, "b")
    sos.commit("Second", ["--force"])  # add nothing, because picky
    _.assertEqual(1, len(os.listdir(branchFolder(0, 2))))
    sos.add(".", "file?")
    sos.commit("Third")  # add nothing, because picky
    _.assertEqual(2, len(os.listdir(branchFolder(0, 3))))
    out = wrapChannels(() -> sos.log()).replace("\r", "")
    _.assertIn("    r2", out)
    _.assertIn("  * r3", out)
    _.assertNotIn("  * r4", out)

  def testTrackedSubfolder(_):
    os.mkdir("." + os.sep + "sub")
    sos.offline("trunk", ["--track"])
    _.createFile(1, "x")
    _.createFile(1, "x", prefix = "sub")
    sos.add(".", "file?")  # add glob pattern to track
    sos.commit("First")
    _.assertEqual(2, len(os.listdir(branchFolder(0, 1))))  # one new file + meta file
    sos.add(".", "sub/file?")  # add glob pattern to track
    sos.commit("Second")  # one new file + meta
    _.assertEqual(2, len(os.listdir(branchFolder(0, 1))))  # one new file + meta file
    os.unlink("file1")  # remove from basefolder
    _.createFile(2, "y")
    sos.rm(".", "sub/file?")
    try: sos.rm(".", "sub/bla"); _.fail()  # raises Exit. TODO test the "suggest a pattern" case
    except: pass
    sos.commit("Third")
    _.assertEqual(2, len(os.listdir(branchFolder(0, 2))))  # one new file + meta
    # TODO check if /file1 and sub/file1 were removed from index

  def testTrackedMode(_):
    ''' Difference in semantics vs simple mode:
          - For remote/other branch we can only know and consider tracked files, thus ignoring all complexity stemming from handling addition of untracked files.
          - For current branch, we can take into account tracked and untracked ones, in theory, but it doesn't make sense.
        In conclusion, using the union of tracking patterns from both sides to find affected files makes sense, but disallow deleting files not present in remote branch.
    '''
    sos.offline("test", options = ["--track"])  # set up repo in tracking mode (SVN- or gitless-style)
    _.createFile(1)
    _.createFile("a123a")  # untracked file "a123a"
    sos.add(".", "file?")  # add glob tracking pattern
    sos.commit("second")  # versions "file1"
    _.assertEqual(2, len(os.listdir(branchFolder(0, 1))))  # one new file + meta file
    out = wrapChannels(() -> sos.status()).replace("\r", "")
    _.assertIn("  | ./file?", out)

    _.createFile(2)  # untracked file "file2"
    sos.commit("third")  # versions "file2"
    _.assertEqual(2, len(os.listdir(branchFolder(0, 2))))  # one new file + meta file

    os.mkdir("." + os.sep + "sub")
    _.createFile(3, prefix = "sub")  # untracked file "sub/file3"
    sos.commit("fourth", ["--force"])  # no tracking pattern matches the subfolder
    _.assertEqual(1, len(os.listdir(branchFolder(0, 3))))  # meta file only, no other tracked path/file

    sos.branch("Other")  # second branch containing file1 and file2 tracked by "./file?"
    sos.rm(".", "file?")  # remove tracking pattern, but don't touch previously created and versioned files
    sos.add(".", "a*a")  # add tracking pattern
    changes = sos.changes()  # should pick up addition
    _.assertEqual(0, len(changes.modifications))
    _.assertEqual(0, len(changes.deletions))  # not tracked anymore, but contained in version history and not removed
    _.assertEqual(1, len(changes.additions))  # detected one addition "a123a", but won't recognize untracking files as deletion

    sos.commit("Second_2")
    _.assertEqual(2, len(os.listdir(branchFolder(1, 1))))  # "a123a" + meta file
    _.assertTrue(os.path.exists("." + os.sep + "file1"))
    _.assertTrue(os.path.exists("." + os.sep + "file2"))

    sos.switch("test")  # go back to first branch - tracks only "file?", but not "a*a"
    _.assertTrue(os.path.exists("." + os.sep + "file1"))
    _.assertTrue(os.path.exists("." + os.sep + "a123a"))  # should not have been touched so far

    sos.update("Other")  # integrate tracked files and tracking pattern from second branch into working state of master branch
    _.assertTrue(os.path.exists("." + os.sep + "file1"))
    _.assertTrue(os.path.exists("." + os.sep + "a123a"))

    _.createFile("axxxa")  # new file that should be tracked on "test" now that we integrated "Other"
    sos.commit("fifth")  # create new revision after integrating updates from second branch
    _.assertEqual(3, len(os.listdir(branchFolder(0, 4))))  # one new file from other branch + one new in current folder + meta file
    sos.switch("Other")  # switch back to just integrated branch that tracks only "a*a" - shouldn't do anything
    _.assertTrue(os.path.exists("." + os.sep + "file1"))
    _.assertTrue(os.path.exists("." + os.sep + "a123a"))
    _.assertFalse(os.path.exists("." + os.sep + "axxxa"))  # because tracked in both branches, but not present in other -> delete in file tree TODO document
    # TODO test switch --meta

  def testLsTracked(_):
    sos.offline("test", options = ["--track"])  # set up repo in tracking mode (SVN- or gitless-style)
    _.createFile(1)
    _.createFile("foo")
    sos.add(".", "file*")  # capture one file
    out = sos.safeSplit(wrapChannels(() -> sos.ls()).replace("\r", ""), "\n")
    _.assertInAny('TRK file1 by "./file*"', out)
    _.assertNotInAny('    file1 by "./file*"', out)
    _.assertInAny("    foo", out)

  def testLsSimple(_):
    _.createFile(1)
    _.createFile("foo")
    _.createFile("ign1")
    _.createFile("ign2")
    sos.offline("test")  # set up repo in tracking mode (SVN- or gitless-style)
    sos.config("set", ["ignores", "ign1"])  # define an ignore pattern
    sos.config("add", ["ignores", "ign2"])  # define an ignore pattern
    sos.config("set", ["ignoresWhitelist", "ign1;ign2"])  # define a list of ignore patterns
    out = wrapChannels(() -> sos.config("show")).replace("\r", "")
    _.assertIn("ignores => ['ign1', 'ign2']", out)
    out = sos.safeSplit(wrapChannels(() -> sos.ls()).replace("\r", ""), "\n")
    _.assertInAny('    file1', out)
    _.assertInAny('    ign1', out)
    _.assertInAny('    ign2', out)
    try: sos.config("rm", ["foo", "bar"]); _.fail()
    except: pass
    try: sos.config("rm", ["ignores", "foo"]); _.fail()
    except: pass
    sos.config("rm", ["ignores", "ign1"])
    sos.config("unset", ["ignoresWhitelist"])  # remove ignore pattern
    out = sos.safeSplit(wrapChannels(() -> sos.ls()).replace("\r", ""), "\n")
    _.assertInAny('    ign1', out)
    _.assertInAny('IGN ign2', out)
    _.assertNotInAny('    ign2', out)

  def testWhitelist(_):
    # TODO test same for simple mode
    _.createFile(1)
    sos.defaults.ignores[:] = ["file*"]  # replace in-place
    sos.offline("xx", ["--track", "--strict"])  # because nothing to commit due to ignore pattern
    sos.add(".", "file*")  # add tracking pattern for "file1"
    sos.commit(options = ["--force"])  # attempt to commit the file
    _.assertEqual(1, len(os.listdir(branchFolder(0, 1))))  # only meta data, file1 was ignored
    try: sos.online(); _.fail()  # Exit because dirty
    except: pass  # exception expected
    _.createFile("x2")  # add another change
    sos.add(".", "x?")  # add tracking pattern for "file1"
    try: sos.online(["--force"]); _.fail()  # force beyond dirty flag check
    except: pass
    sos.online(["--force", "--force"])  # force beyond file tree modifications check
    _.assertFalse(os.path.exists(sos.metaFolder))

    _.createFile(1)
    sos.defaults.ignoresWhitelist[:] = ["file*"]
    sos.offline("xx", ["--track"])
    sos.add(".", "file*")
    sos.commit()  # should NOT ask for force here
    _.assertEqual(2, len(os.listdir(branchFolder(0, 1))))  # meta data and "file1", file1 was whitelisted

  def testRemove(_):
    _.createFile(1, "x" * 100)
    sos.offline("trunk")
    try: sos.delete("trunk"); _fail()
    except: pass
    _.createFile(2, "y" * 10)
    sos.branch("added")
    sos.delete("trunk")
    import pdb; pdb.set_trace()
    _.assertEqual(2, len(os.listdir("." + os.sep + sos.metaFolder)))  # meta data file and "b1"
    _.assertTrue(os.path.exists("." + os.sep + sos.metaFolder + os.sep + "b1"))
    _.assertFalse(os.path.exists("." + os.sep + sos.metaFolder + os.sep + "b0"))
    sos.branch("next")
    _.createFile(3, "y" * 10)  # make a change
    sos.delete("added", "--force")  # should succeed

  def testUsage(_):
    sos.usage()

  def testDiff(_):
    sos.offline(options = ["--strict"])
    _.createFile(1)
    sos.commit()
    _.createFile(1, "sdfsdgfsdf")
    time.sleep(1.1)
    sos.commit()
    _.createFile(1, "foobar")
    _.assertAllIn(["MOD ./file1", "DIF ./file1", "- | 0000 |xxxxxxxxxx|", "+ | 0000 |foobar|"], wrapChannels(() -> sos.diff("/-2")))  # second last

  def testFindBase(_):
    old = os.getcwd()
    try:
        os.mkdir("." + os.sep + ".git")
        os.makedirs("." + os.sep + "a" + os.sep + sos.metaFolder)
        os.makedirs("." + os.sep + "a" + os.sep + "b")
        os.chdir("a" + os.sep + "b")
        s, vcs, cmd = sos.findSosVcsBase()
        _.assertIsNotNone(s)
        _.assertIsNotNone(vcs)
        _.assertEqual("git", cmd)
    finally: os.chdir(old)


if __name__ == '__main__':
  logging.basicConfig(level = logging.DEBUG if '-v' in sys.argv or os.getenv("DEBUG", "false").strip().lower() == "true" or os.getenv("CI", "false").strip().lower() == "true" else logging.INFO , stream = sys.stderr, format = "%(asctime)-23s %(levelname)-8s %(name)s:%(lineno)d | %(message)s" if '-v' in sys.argv or os.getenv("DEBUG", "false") == "true" else "%(message)s")
  if configr:
    c = configr.Configr("sos"); c.loadSettings()
    if len(c.keys()) > 0: sos.Exit("Cannot run test suite with existing local SOS user configuration (would affect results)")
  unittest.main(testRunner = debugTestRunner() if '-v' in sys.argv and not os.getenv("BUILD", "false").lower() == "true" else None)  # warnings = "ignore")
