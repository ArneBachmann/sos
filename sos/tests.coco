import builtins, json, logging, os, shutil, sys, time, traceback, unittest, uuid
StringIO = (__import__("StringIO" if sys.version_info.major < 3 else "io")).StringIO  # enables import via ternary expression
try: from unittest import mock  # Py3
except: import mock  # installed via pip
try: from typing import Any, List, Union  # only required for mypy
except: pass

testFolder = os.path.abspath(os.path.join(os.getcwd(), "test"))
try:
  import configr  # optional dependency
  os.environ["TEST"] = testFolder  # needed to mock configr library calls in sos
except: configr = None  # declare as undefined
import sos
sos.defaults["defaultbranch"] = "trunk"  # because sos.main() is never called

def sync() -> None:
  if (sys.version_info.major, sys.version_info.minor) >= (3, 3): os.sync()


def determineFilesystemTimeResolution() -> float =
  name = str(uuid.uuid4())
  with open(name, "w") as fd: fd.write("x")  # create temporary file
  mt = os.stat(name)[8]  # get current timestamp
  while os.stat(name)[8] == mt:  # wait until timestamp modified
    with open(name, "w") as fd: fd.write("x")
  mt, start, count = os.stat(name)[8], time.time(), 0
  while os.stat(name)[8] == mt:  # now cound and measure time until modified again
    count += 1
    with open(name, "w") as fd: fd.write("x")
  os.unlink(name)
  fsprecision = round(time.time() - start, 2)
  print("File system timestamp precision is %.2fs; wrote to the file %d times during that time" % (fsprecision, count))
  fsprecision


FS_PRECISION = determineFilesystemTimeResolution() * 1.05


def debugTestRunner(post_mortem = None) =
  ''' Unittest runner doing post mortem debugging on failing tests. '''
  import pdb
  if post_mortem is None: post_mortem = pdb.post_mortem
  class DebugTestResult(unittest.TextTestResult):
    def addError(self, test, err):  # called before tearDown()
      traceback.print_exception(*err)
      post_mortem(err[2])
      super(DebugTestResult, self).addError(test, err)
    def addFailure(self, test, err):
      traceback.print_exception(*err)
      post_mortem(err[2])
      super(DebugTestResult, self).addFailure(test, err)
  unittest.TextTestRunner(resultclass = DebugTestResult)

def branchFolder(branch:int, revision:int) -> str = "." + os.sep + sos.metaFolder + os.sep + "b%d" % branch + os.sep + "r%d" % revision

def wrapChannels(func: -> Any) =
  ''' Wrap function call to capture and return strings emitted on stdout and stderr. '''
  oldv, oldo, olde = sys.argv, sys.stdout, sys.stderr
  buf = StringIO()
  sys.stdout = sys.stderr = buf
  handler = logging.StreamHandler(buf)
  logging.getLogger().addHandler(handler)
  try: func()  # capture output into buf
  except Exception as E: buf.write(str(E) + "\n"); traceback.print_exc(file = buf)
  except SystemExit as F: buf.write(str(F) + "\n"); traceback.print_exc(file = buf)
  logging.getLogger().removeHandler(handler)
  sys.argv, sys.stdout, sys.stderr = oldv, oldo, olde
  buf.getvalue()

def mockInput(datas:str[], func) -> Any:
  with mock.patch("builtins.input" if sys.version_info.major >= 3 else "utility._coconut_raw_input", side_effect = datas): return func()

def setRepoFlag(name:str, value:bool) -> None:
  with open(sos.metaFolder + os.sep + sos.metaFile, "r") as fd: flags, branches = json.loads(fd.read())
  flags[name] = value
  with open(sos.metaFolder + os.sep + sos.metaFile, "w") as fd: fd.write(json.dumps((flags, branches)))

def checkRepoFlag(name:str, flag:bool) -> bool =
  with open(sos.metaFolder + os.sep + sos.metaFile, "r") as fd: flags, branches = json.loads(fd.read())
  name in flags and flags[name] == flag


class Tests(unittest.TestCase):
  ''' Entire test suite. '''

  def setUp(_):
    for entry in os.listdir(testFolder):  # cannot remove testFolder on Windows when using TortoiseSVN as VCS
      resource = os.path.join(testFolder, entry)
      shutil.rmtree(resource) if os.path.isdir(resource) else os.unlink(resource)
    os.chdir(testFolder)

  def assertAllIn(_, what:str[], where:Union[str,List[str]]) -> None: [_.assertIn(w, where) for w in what]

  def assertInAll(_, what:str, where:str[]) -> None: [_.assertIn(what, w) for w in where]

  def assertInAny(_, what:str, where:str[]) -> None: _.assertTrue(any(what in w for w in where))

  def assertNotInAny(_, what:str, where:str[]) -> None: _.assertFalse(any(what in w for w in where))

  def createFile(_, number:Union[int,str], contents:str = "x" * 10, prefix:str? = None) -> None:
    if prefix and not os.path.exists(prefix): os.makedirs(prefix)
    with open(("." if prefix is None else prefix) + os.sep + (("file%d" % number) if isinstance(number, int) else number), "wb") as fd: fd.write(contents if isinstance(contents, bytes) else contents.encode("cp1252"))

  def existsFile(_, number:Union[int, str], expectedContents:bytes = None) -> bool:
    if not os.path.exists(("." + os.sep + "file%d" % number) if isinstance(number, int) else number): return False
    if expectedContents is None: return True
    with open(("." + os.sep + "file%d" % number) if isinstance(number, int) else number, "rb") as fd: return fd.read() == expectedContents

  def testAccessor(_):
     a = sos.Accessor({"a": 1})
     _.assertEqual((1, 1), (a["a"], a.a))

  def testFirstofmap(_):
    _.assertEqual(2, sos.firstOfMap({"a": 1, "b": 2}, ["x", "b"]))
    _.assertIsNone(sos.firstOfMap({"a": 1, "b": 2}, []))

  def testAjoin(_):
    _.assertEqual("a1a2", sos.ajoin("a", ["1", "2"]))
    _.assertEqual("* a\n* b", sos.ajoin("* ", ["a", "b"], "\n"))

  def testFindChanges(_):
    m = sos.Metadata(os.getcwd())
    m.loadBranches()
    _.createFile(1, "1")
    m.createBranch(0)
    _.assertEqual(1, len(m.paths))
    time.sleep(FS_PRECISION)  # time required by filesystem time resolution issues
    _.createFile(1, "2")
    _.createFile(2, "2")
    changes = m.findChanges()  # detect time skew
    _.assertEqual(1, len(changes.additions))
    _.assertEqual(0, len(changes.deletions))
    _.assertEqual(1, len(changes.modifications))
    m.integrateChangeset(changes)
    _.createFile(2, "12")  # modify file
    changes = m.findChanges(0, 1)  # by size, creating new commit
    _.assertEqual(0, len(changes.additions))
    _.assertEqual(0, len(changes.deletions))
    _.assertEqual(1, len(changes.modifications))
    _.assertTrue(os.path.exists(branchFolder(0, 1)))
    _.assertTrue(os.path.exists(branchFolder(0, 1) + os.sep + "03b69bc801ae11f1ff2a71a50f165996d0ad681b4f822df13329a27e53f0fcd2"))

  def testDiffFunc(_):
    a = {"./a": sos.PathInfo("", 0, 0, "")}
    b = {"./a": sos.PathInfo("", 0, 0, "")}
    changes = sos.diffPathSets(a, b)
    _.assertEqual(0, len(changes.additions))
    _.assertEqual(0, len(changes.deletions))
    _.assertEqual(0, len(changes.modifications))
    b = {"./a": sos.PathInfo("", 1, 0, "")}
    changes = sos.diffPathSets(a, b)
    _.assertEqual(0, len(changes.additions))
    _.assertEqual(0, len(changes.deletions))
    _.assertEqual(1, len(changes.modifications))
    b = {}  # diff contains no entries -> no change
    changes = sos.diffPathSets(a, b)
    _.assertEqual(0, len(changes.additions))
    _.assertEqual(0, len(changes.deletions))
    _.assertEqual(0, len(changes.modifications))
    b = {"./a": sos.PathInfo("", None, 1, "")}  # in diff marked as deleted
    changes = sos.diffPathSets(a, b)
    _.assertEqual(0, len(changes.additions))
    _.assertEqual(1, len(changes.deletions))
    _.assertEqual(0, len(changes.modifications))
    b = {"./b": sos.PathInfo("", 1, 1, "")}
    changes = sos.diffPathSets(a, b)
    _.assertEqual(1, len(changes.additions))
    _.assertEqual(0, len(changes.deletions))
    _.assertEqual(0, len(changes.modifications))
    a = {"./a": sos.PathInfo("", None, 0, "")}  # mark as deleted
    b = {"./a": sos.PathInfo("", 1, 0, "")}  # re-added
    changes = sos.diffPathSets(a, b)
    _.assertEqual(1, len(changes.additions))
    _.assertEqual(0, len(changes.deletions))
    _.assertEqual(0, len(changes.modifications))
    changes = sos.diffPathSets(b, a)
    _.assertEqual(0, len(changes.additions))
    _.assertEqual(1, len(changes.deletions))
    _.assertEqual(0, len(changes.modifications))

  def testPatternPaths(_):
    sos.offline(options = ["--track"])
    os.mkdir("sub")
    _.createFile("sub" + os.sep + "file1", "sdfsdf")
    sos.add("sub", "sub/file?")
    sos.commit("test")  # should pick up sub/file1 pattern
    _.assertEqual(2, len(os.listdir(os.path.join(sos.metaFolder, "b0", "r1"))))  # sub/file1 was added
    _.createFile(1)
    try: sos.commit("nothing"); _.fail()  # should not commit anything, as the file in base folder doesn't match the tracked pattern
    except: pass

  def testTokenizeGlobPattern(_):
    _.assertEqual([], sos.tokenizeGlobPattern(""))
    _.assertEqual([sos.GlobBlock(False, "*", 0)], sos.tokenizeGlobPattern("*"))
    _.assertEqual([sos.GlobBlock(False, "*", 0), sos.GlobBlock(False, "???", 1)], sos.tokenizeGlobPattern("*???"))
    _.assertEqual([sos.GlobBlock(True, "x", 0),  sos.GlobBlock(False, "*", 1),  sos.GlobBlock(True, "x", 2)], sos.tokenizeGlobPattern("x*x"))
    _.assertEqual([sos.GlobBlock(True, "x", 0),  sos.GlobBlock(False, "*", 1),  sos.GlobBlock(False, "??", 2), sos.GlobBlock(False, "*", 4), sos.GlobBlock(True, "x", 5)], sos.tokenizeGlobPattern("x*??*x"))
    _.assertEqual([sos.GlobBlock(False, "?", 0), sos.GlobBlock(True, "abc", 1), sos.GlobBlock(False, "*", 4)], sos.tokenizeGlobPattern("?abc*"))

  def testTokenizeGlobPatterns(_):
    try: sos.tokenizeGlobPatterns("x*x", "x*"); _.fail()  # because number of literal strings differs
    except: pass
    try: sos.tokenizeGlobPatterns("x*", "x?"); _.fail()  # because glob patterns differ
    except: pass
    try: sos.tokenizeGlobPatterns("x*", "?x"); _.fail()  # glob patterns differ, regardless of position
    except: pass
    sos.tokenizeGlobPatterns("x*", "*x")  # succeeds, because glob patterns match (differ only in position)
    sos.tokenizeGlobPatterns("*xb?c", "*x?bc")  # succeeds, because glob patterns match (differ only in position)
    try: sos.tokenizeGlobPatterns("a???b*", "ab???*"); _.fail()  # succeeds, because glob patterns match (differ only in position)
    except: pass
  
  def testConvertGlobFiles(_):
    _.assertEqual(["xxayb", "aacb"], [r[1] for r in sos.convertGlobFiles(["axxby", "aabc"], *sos.tokenizeGlobPatterns("a*b?", "*a?b"))])
    _.assertEqual(["1qq2ww3", "1abcbx2xbabc3"], [r[1] for r in sos.convertGlobFiles(["qqxbww", "abcbxxbxbabc"], *sos.tokenizeGlobPatterns("*xb*", "1*2*3"))])

  def testFolderRemove(_):
    m = sos.Metadata(os.getcwd())
    _.createFile(1)
    _.createFile("a", prefix = "sub")
    sos.offline()
    _.createFile(2)
    os.unlink("sub" + os.sep + "a")
    os.rmdir("sub")
    changes = sos.changes()
    _.assertEqual(1, len(changes.additions))
    _.assertEqual(0, len(changes.modifications))
    _.assertEqual(1, len(changes.deletions))
    _.createFile("a", prefix = "sub")
    changes = sos.changes()
    _.assertEqual(0, len(changes.deletions))

  def testComputeSequentialPathSet(_):
    os.makedirs(branchFolder(0, 0))
    os.makedirs(branchFolder(0, 1))
    os.makedirs(branchFolder(0, 2))
    os.makedirs(branchFolder(0, 3))
    os.makedirs(branchFolder(0, 4))
    m = sos.Metadata(os.getcwd())
    m.branch = 0
    m.commit = 2
    m.saveBranches()
    m.paths = {"./a": sos.PathInfo("", 0, 0, "")}
    m.saveCommit(0, 0)  # initial
    m.paths["./a"] = sos.PathInfo("", 1, 0, "")
    m.saveCommit(0, 1)  # mod
    m.paths["./b"] = sos.PathInfo("", 0, 0, "")
    m.saveCommit(0, 2)  # add
    m.paths["./a"] = sos.PathInfo("", None, 0, "")
    m.saveCommit(0, 3)  # del
    m.paths["./a"] = sos.PathInfo("", None, 0, "")
    m.saveCommit(0, 4)  # readd
    m.commits = {i: sos.CommitInfo(i, 0, None) for i in range(5)}
    m.saveBranch(0)
    m.computeSequentialPathSet(0, 4)
    _.assertEqual(2, len(m.paths))

  def testParseRevisionString(_):
    m = sos.Metadata(os.getcwd())
    m.branch = 1
    m.commits = {0: 0, 1:1, 2:2}
    _.assertEqual((1, 3), m.parseRevisionString("3"))
    _.assertEqual((2, 3), m.parseRevisionString("2/3"))
    _.assertEqual((1, -1), m.parseRevisionString(None))
    _.assertEqual((1, -1), m.parseRevisionString(""))
    _.assertEqual((2, -1), m.parseRevisionString("2/"))
    _.assertEqual((1, -2), m.parseRevisionString("/-2"))
    _.assertEqual((1, -1), m.parseRevisionString("/"))

  def testOfflineEmpty(_):
    os.mkdir("." + os.sep + sos.metaFolder)
    try: sos.offline("trunk"); _.fail()
    except SystemExit: pass
    os.rmdir("." + os.sep + sos.metaFolder)
    sos.offline("test")
    _.assertIn(sos.metaFolder, os.listdir("."))
    _.assertAllIn(["b0", sos.metaFile], os.listdir("." + os.sep + sos.metaFolder))
    _.assertAllIn(["r0", sos.metaFile], os.listdir("." + os.sep + sos.metaFolder + os.sep + "b0"))
    _.assertEqual(2, len(os.listdir("." + os.sep + sos.metaFolder)))  # only branch folder and meta data file
    _.assertEqual(2, len(os.listdir("." + os.sep + sos.metaFolder + os.sep + "b0")))  # only commit folder and meta data file
    _.assertEqual(1, len(os.listdir(branchFolder(0, 0))))  # only meta data file

  def testOfflineWithFiles(_):
    _.createFile(1, "x" * 100)
    _.createFile(2)
    sos.offline("test")
    _.assertAllIn(["file1", "file2", sos.metaFolder], os.listdir("."))
    _.assertAllIn(["b0", sos.metaFile], os.listdir("." + os.sep + sos.metaFolder))
    _.assertAllIn(["r0", sos.metaFile], os.listdir("." + os.sep + sos.metaFolder + os.sep + "b0"))
    _.assertAllIn([sos.metaFile, "03b69bc801ae11f1ff2a71a50f165996d0ad681b4f822df13329a27e53f0fcd2", "b9ee10a87f612e299a6eb208210bc0898092a64c48091327cc2aaeee9b764ffa"], os.listdir("." + os.sep + sos.metaFolder + os.sep + "b0" + os.sep + "r0"))
    _.assertEqual(2, len(os.listdir("." + os.sep + sos.metaFolder)))  # only branch folder and meta data file
    _.assertEqual(2, len(os.listdir("." + os.sep + sos.metaFolder + os.sep + "b0")))  # only commit folder and meta data file
    _.assertEqual(3, len(os.listdir(branchFolder(0, 0))))  # only meta data file plus branch base file copies

  def testBranch(_):
    _.createFile(1, "x" * 100)
    _.createFile(2)
    sos.offline("test")  # b0/r0
    sos.branch("other")  # b1/r0
    _.assertAllIn(["b0", "b1", sos.metaFile], os.listdir("." + os.sep + sos.metaFolder))
    _.assertEqual(list(sorted(os.listdir("." + os.sep + sos.metaFolder + os.sep + "b0"))),
                  list(sorted(os.listdir("." + os.sep + sos.metaFolder + os.sep + "b1"))))
    _.assertEqual(list(sorted(os.listdir(branchFolder(0, 0)))),
                  list(sorted(os.listdir(branchFolder(1, 0)))))
    _.createFile(1, "z")  # modify file
    sos.branch()  # b2/r0  branch to unnamed branch with modified file tree contents
    _.assertNotEqual(os.stat("." + os.sep + sos.metaFolder + os.sep + "b1" + os.sep + "r0" + os.sep + "b9ee10a87f612e299a6eb208210bc0898092a64c48091327cc2aaeee9b764ffa").st_size,
                     os.stat("." + os.sep + sos.metaFolder + os.sep + "b2" + os.sep + "r0" + os.sep + "b9ee10a87f612e299a6eb208210bc0898092a64c48091327cc2aaeee9b764ffa").st_size)
    _.createFile(3, "z")
    sos.branch("from_last_revision", ["--last", "--stay"])  # b3/r0 create copy of other file1,file2 and don't switch
    _.assertEqual(list(sorted(os.listdir("." + os.sep + sos.metaFolder + os.sep + "b3" + os.sep + "r0"))),
                  list(sorted(os.listdir("." + os.sep + sos.metaFolder + os.sep + "b2" + os.sep + "r0"))))
    # Check sos.status output which branch is marked


  def testComittingAndChanges(_):
    _.createFile(1, "x" * 100)
    _.createFile(2)
    sos.offline("test")
    changes = sos.changes()
    _.assertEqual(0, len(changes.additions))
    _.assertEqual(0, len(changes.deletions))
    _.assertEqual(0, len(changes.modifications))
    _.createFile(1, "z")  # size change
    changes = sos.changes()
    _.assertEqual(0, len(changes.additions))
    _.assertEqual(0, len(changes.deletions))
    _.assertEqual(1, len(changes.modifications))
    sos.commit("message")
    _.assertAllIn(["r0", "r1", sos.metaFile], os.listdir("." + os.sep + sos.metaFolder + os.sep + "b0"))
    _.assertAllIn([sos.metaFile, "b9ee10a87f612e299a6eb208210bc0898092a64c48091327cc2aaeee9b764ffa"], os.listdir(branchFolder(0, 1)))
    _.assertEqual(2, len(os.listdir(branchFolder(0, 1))))  # no further files, only the modified one
    _.assertEqual(1, len(sos.changes("/0").modifications))  # vs. explicit revision on current branch
    _.assertEqual(1, len(sos.changes("0/0").modifications))  # vs. explicit branch/revision
    _.createFile(1, "")  # modify to empty file, mentioned in meta data, but not stored as own file
    os.unlink("file2")
    changes = sos.changes()
    _.assertEqual(0, len(changes.additions))
    _.assertEqual(1, len(changes.deletions))
    _.assertEqual(1, len(changes.modifications))
    sos.commit("modified")
    _.assertEqual(1, len(os.listdir(branchFolder(0, 2))))  # no additional files, only mentions in metadata
    try: sos.commit("nothing"); _.fail()  # expecting Exit due to no changes
    except: pass

  def testGetBranch(_):
    m = sos.Metadata(os.getcwd())
    m.branch = 1  # current branch
    m.branches = {0: sos.BranchInfo(0, 0, "trunk")}
    _.assertEqual(27, m.getBranchByName(27))
    _.assertEqual(0, m.getBranchByName("trunk"))
    _.assertEqual(1, m.getBranchByName(""))  # split from "/"
    _.assertIsNone(m.getBranchByName("unknown"))
    m.commits = {0: sos.CommitInfo(0, 0, "bla")}
    _.assertEqual(13, m.getRevisionByName("13"))
    _.assertEqual(0, m.getRevisionByName("bla"))
    _.assertEqual(-1, m.getRevisionByName(""))  # split from "/"

  def testTagging(_):
    m = sos.Metadata(os.getcwd())
    sos.offline()
    _.createFile(111)
    sos.commit("tag", ["--tag"])
    _.createFile(2)
    try: sos.commit("tag"); _.fail()
    except: pass
    sos.commit("tag-2", ["--tag"])

  def testSwitch(_):
    _.createFile(1, "x" * 100)
    _.createFile(2, "y")
    sos.offline("test")  # file1-2  in initial branch commit
    sos.branch("second")  # file1-2  switch, having same files
    sos.switch("0")  # no change  switch back, no problem
    sos.switch("second")  # no change  # switch back, no problem
    _.createFile(3, "y")  # generate a file
    try: sos.switch("test"); _.fail()  # uncommited changes detected
    except SystemExit: pass
    sos.commit("Finish")  # file1-3  commit third file into branch second
    sos.changes()
    sos.switch("test")  # file1-2, remove file3 from file tree
    _.assertFalse(_.existsFile(3))  # removed when switching back to test
    out = wrapChannels(() -> sos.status()).replace("\r", "")
    _.assertIn("  * b00   'test'", out)
    _.assertIn("    b01 'second'", out)
    _.assertIn("(dirty)", out)  # one branch has commits
    _.assertIn("(in sync)", out)  # the other doesn't
    _.createFile(4, "xy")  # generate a file
    sos.switch("second", "--force")  # avoids warning on uncommited changes, but keeps file4
    _.assertFalse(_.existsFile(4))  # removed when forcedly switching back to test
    _.assertTrue(_.existsFile(3))  # was restored from branch's revision r1
    os.unlink("." + os.sep + "file1")  # remove old file1
    sos.switch("test", "--force")  # should restore file1 and remove file3
    _.assertTrue(_.existsFile(1))  # was restored from branch's revision r1
    _.assertFalse(_.existsFile(3))  # was restored from branch's revision r1

  def testAutoDetectVCS(_):
    os.mkdir(".git")
    sos.offline(sos.vcsBranches[sos.findSosVcsBase()[2]])  # create initial branch
    with open(sos.metaFolder + os.sep + sos.metaFile, "r") as fd: meta = fd.read()
    _.assertTrue("\"master\"" in meta)
    os.rmdir(".git")

  def testUpdate(_):
    sos.offline("trunk")  # create initial branch b0/r0
    _.createFile(1, "x" * 100)
    sos.commit("second")  # create b0/r1

    sos.switch("/0")  # go back to b0/r0 - deletes file1
    _.assertFalse(_.existsFile(1))

    sos.update("/1")  # recreate file1
    _.assertTrue(_.existsFile(1))

    sos.commit("third", ["--force"])  # force because nothing to commit. should create r2 with same contents as r1, but as differential from r1, not from r0 (= no changes in meta folder)
    _.assertTrue(os.path.exists(branchFolder(0, 2)))
    _.assertTrue(os.path.exists(branchFolder(0, 2) + os.sep + sos.metaFile))
    _.assertEqual(1, len(os.listdir(branchFolder(0, 2))))  # only meta data file, no differential files

    sos.update("/1")  # do nothing, as nothing has changed
    _.assertTrue(_.existsFile(1))

    _.createFile(2, "y" * 100)
#    out = wrapChannels(() -> sos.branch("other"))  # won't comply as there are changes
#    _.assertIn("--force", out)
    sos.branch("other", ["--force"])  # automatically including file 2 (as we are in simple mode)
    _.assertTrue(_.existsFile(2))
    sos.update("trunk", ["--add"])  # only add stuff
    _.assertTrue(_.existsFile(2))
    sos.update("trunk")  # nothing to do
    _.assertFalse(_.existsFile(2))  # removes file not present in original branch

    theirs = b"a\nb\nc\nd\ne\nf\ng\nh\nx\nx\nj\nk"
    _.createFile(10, theirs)
    mine = b"a\nc\nd\ne\ng\nf\nx\nh\ny\ny\nj"  # missing "b", inserted g, modified g->x, replace x/x -> y/y, removed k
    _.createFile(11, mine)
    _.assertEqual(b"a\nb\nc\nd\ne\nf\ng\nh\nx\nx\nj\nk",    sos.merge(filename = "." + os.sep + "file10", intoname = "." + os.sep + "file11", mergeOperation = sos.MergeOperation.BOTH, conflictResolution = sos.ConflictResolution.THEIRS))  # completely recreated other file
    _.assertEqual(b"a\nb\nc\nd\ne\ng\nf\ng\nx\nh\nx\nx\ny\ny\nj\nk", sos.merge(filename = "." + os.sep + "file10", intoname = "." + os.sep + "file11", mergeOperation = sos.MergeOperation.INSERT, conflictResolution = sos.ConflictResolution.MINE))

  def testUpdate2(_):
    _.createFile("test.txt", "x" * 10)
    sos.offline("trunk", ["--strict"])  # use strict mode, as timestamp differences are too small for testing
    sos.branch("mod")
    _.createFile("test.txt", "x" * 5 + "y" * 5)
    time.sleep(FS_PRECISION)
    sos.commit("mod")  # create b0/r1
    sos.switch("trunk", ["--force"])  # should replace contents, force in case some other files were modified (e.g. during working on the code) TODO investigate more
    with open("test.txt", "rb") as fd: _.assertEqual(b"x" * 10, fd.read())
    sos.update("mod", ["--theirs"])  # integrate changes TODO same with ask -> theirs
    with open("test.txt", "rb") as fd: _.assertEqual(b"x" * 5 + b"y" * 5, fd.read())
    _.createFile("test.txt", "x" * 10)
    mockInput(["t"], () -> sos.update("mod", ["--ask"]))  # same as above with interaction -> theirs
    with open("test.txt", "rb") as fd: _.assertEqual(b"x" * 5 + b"y" * 5, fd.read())

  def testIsTextType(_):
    m = sos.Metadata(".")
    m.c.texttype = ["*.x", "*.md", "*.md.*"]
    m.c.bintype = ["*.md.confluence"]
    _.assertTrue(m.isTextType("ab.txt"))
    _.assertTrue(m.isTextType("./ab.txt"))
    _.assertTrue(m.isTextType("bc/ab.txt"))
    _.assertFalse(m.isTextType("bc/ab."))
    _.assertTrue(m.isTextType("23_3.x.x"))
    _.assertTrue(m.isTextType("dfg/dfglkjdf7/test.md"))
    _.assertTrue(m.isTextType("./test.md.pdf"))
    _.assertFalse(m.isTextType("./test_a.md.confluence"))

  def testEolDet(_):
    ''' Check correct end-of-line detection. '''
    _.assertEqual(b"\n", sos.eoldet(b"a\nb"))
    _.assertEqual(b"\r\n", sos.eoldet(b"a\r\nb\r\n"))
    _.assertEqual(b"\r", sos.eoldet(b"\ra\rb"))
    _.assertAllIn(["Inconsistent", "with "], wrapChannels(() -> _.assertEqual(b"\n", sos.eoldet(b"\r\na\r\nb\n"))))
    _.assertAllIn(["Inconsistent", "without"], wrapChannels(() -> _.assertEqual(b"\n", sos.eoldet(b"\ra\nnb\n"))))
    _.assertIsNone(sos.eoldet(b""))
    _.assertIsNone(sos.eoldet(b"sdf"))

  def testMerge(_):
    ''' Check merge results depending on conflict solution options. '''
    a = b"a\nb\ncc\nd"
    b = b"a\nb\nee\nd"
    _.assertEqual(b"a\nb\ncc\nee\nd", sos.merge(a, b, mergeOperation = sos.MergeOperation.INSERT))  # means insert changes from a into b, but don't replace
    _.assertEqual(b"a\nb\nd",         sos.merge(a, b, mergeOperation = sos.MergeOperation.REMOVE))
    _.assertEqual(b"a\nb\ncc\nd",     sos.merge(a, b, mergeOperation = sos.MergeOperation.BOTH))
    # Now test intra-line merging without conflicts
    _.assertEqual(b"a\nbc d\ne", sos.merge(b"a\nbc d\ne", b"a\nbcd\ne", mergeOperation = sos.MergeOperation.INSERT))  # because it's a deletion ['  a', '- bc d', '?   -\n', '+ bcd', '  e']
    _.assertEqual(b"a\nbcd\ne",  sos.merge(b"a\nbc d\ne", b"a\nbcd\ne", mergeOperation = sos.MergeOperation.REMOVE))  # ['  a', '- bc d', '?   -\n', '+ bcd', '  e']
    _.assertEqual(b"a\nbc d\ne", sos.merge(b"a\nbcd\ne", b"a\nbc d\ne", mergeOperation = sos.MergeOperation.INSERT))  # nothing to insert
    _.assertEqual(b"a\nbcd\ne",  sos.merge(b"a\nbcd\ne", b"a\nbc d\ne", mergeOperation = sos.MergeOperation.REMOVE))  # remove space
    # Test with change + insert (conflict)
    _.assertEqual(b"a\nb fdd d\ne", sos.merge(b"a\nb cd d\ne", b"a\nb fdd d\ne", conflictResolution = sos.ConflictResolution.MINE))
    _.assertEqual(b"a\nb cd d\ne",  sos.merge(b"a\nb cd d\ne", b"a\nb fdd d\ne", conflictResolution = sos.ConflictResolution.THEIRS))  # ['  a', '- b cd d', '?   ^\n', '+ b fdd d', '?   ^^\n', '  e']
    _.assertEqual(b"a\nb fdd d\ne", mockInput(["i"], () -> sos.merge(b"a\nb cd d\ne", b"a\nb fdd d\ne", conflictResolution = sos.ConflictResolution.ASK)))  # ['  a', '- b cd d', '?   ^\n', '+ b fdd d', '?   ^^\n', '  e']
    _.assertEqual(b"a\nb cd d\ne",  mockInput(["t"], () -> sos.merge(b"a\nb cd d\ne", b"a\nb fdd d\ne", conflictResolution = sos.ConflictResolution.ASK)))  # ['  a', '- b cd d', '?   ^\n', '+ b fdd d', '?   ^^\n', '  e']
    _.assertEqual(b"abbc", sos.merge(b"abbc", b"addc", mergeOperation = sos.MergeOperation.BOTH, conflictResolution = sos.ConflictResolution.THEIRS))
    _.assertEqual(b"a\nbb\nc", sos.merge(b"a\nbb\nc", b"a\ndd\nc", mergeOperation = sos.MergeOperation.BOTH, conflictResolution = sos.ConflictResolution.THEIRS))
    _.assertIn("Differing EOL-styles", wrapChannels(() -> sos.merge(b"a\nb", b"a\r\nb")))  # expect warning
    _.assertIn(b"a\r\nb", sos.merge(b"a\nb", b"a\r\nb"))  # in doubt, use "mine" CR-LF

  def testPickyMode(_):
    ''' Confirm that picky mode reset tracked patterns after commits. '''
    sos.offline("trunk", ["--picky"])
    changes = sos.changes()
    _.assertEqual(0, len(changes.additions))  # do not list any existing file as an addition
    sos.add(".", "./file?", ["--force"])
    _.createFile(1, "aa")
    sos.commit("First")  # add one file
    _.assertEqual(2, len(os.listdir(branchFolder(0, 1))))
    _.createFile(2, "b")
    try: sos.commit("Second")  # add nothing, because picky
    except: pass
    sos.add(".", "./file?")
    sos.commit("Third")
    _.assertEqual(2, len(os.listdir(branchFolder(0, 2))))
    out = wrapChannels(() -> sos.log([])).replace("\r", "")
    _.assertIn("  * r2", out)
    _.createFile(3, prefix = "sub")
    sos.add("sub", "sub/file?")
    changes = sos.changes()
    _.assertEqual(1, len(changes.additions))
    _.assertTrue("sub/file3" in changes.additions)

  def testTrackedSubfolder(_):
    ''' See if patterns for files in sub folders are picked up correctly. '''
    os.mkdir("." + os.sep + "sub")
    sos.offline("trunk", ["--track"])
    _.createFile(1, "x")
    _.createFile(1, "x", prefix = "sub")
    sos.add(".", "./file?")  # add glob pattern to track
    sos.commit("First")
    _.assertEqual(2, len(os.listdir(branchFolder(0, 1))))  # one new file + meta file
    sos.add(".", "sub/file?")  # add glob pattern to track
    sos.commit("Second")  # one new file + meta
    _.assertEqual(2, len(os.listdir(branchFolder(0, 1))))  # one new file + meta file
    os.unlink("file1")  # remove from basefolder
    _.createFile(2, "y")
    sos.remove(".", "sub/file?")
    try: sos.remove(".", "sub/bla"); _.fail()  # raises Exit. TODO test the "suggest a pattern" case
    except: pass
    sos.commit("Third")
    _.assertEqual(2, len(os.listdir(branchFolder(0, 2))))  # one new file + meta
    # TODO check if /file1 and sub/file1 were removed from index

  def testTrackedMode(_):
    ''' Difference in semantics vs simple mode:
          - For remote/other branch we can only know and consider tracked files, thus ignoring all complexity stemming from handling addition of untracked files.
          - For current branch, we can take into account tracked and untracked ones, in theory, but it doesn't make sense.
        In conclusion, using the union of tracking patterns from both sides to find affected files makes sense, but disallow deleting files not present in remote branch.
    '''
    sos.offline("test", options = ["--track"])  # set up repo in tracking mode (SVN- or gitless-style)
    _.createFile(1)
    _.createFile("a123a")  # untracked file "a123a"
    sos.add(".", "./file?")  # add glob tracking pattern
    sos.commit("second")  # versions "file1"
    _.assertEqual(2, len(os.listdir(branchFolder(0, 1))))  # one new file + meta file
    out = wrapChannels(() -> sos.status()).replace("\r", "")
    _.assertIn("  | ./file?", out)

    _.createFile(2)  # untracked file "file2"
    sos.commit("third")  # versions "file2"
    _.assertEqual(2, len(os.listdir(branchFolder(0, 2))))  # one new file + meta file

    os.mkdir("." + os.sep + "sub")
    _.createFile(3, prefix = "sub")  # untracked file "sub/file3"
    sos.commit("fourth", ["--force"])  # no tracking pattern matches the subfolder
    _.assertEqual(1, len(os.listdir(branchFolder(0, 3))))  # meta file only, no other tracked path/file

    sos.branch("Other")  # second branch containing file1 and file2 tracked by "./file?"
    sos.remove(".", "./file?")  # remove tracking pattern, but don't touch previously created and versioned files
    sos.add(".", "./a*a")  # add tracking pattern
    changes = sos.changes()  # should pick up addition only, because tracked, but not the deletion, as not tracked anymore
    _.assertEqual(0, len(changes.modifications))
    _.assertEqual(0, len(changes.deletions))  # not tracked anymore, but contained in version history and not removed
    _.assertEqual(1, len(changes.additions))  # detected one addition "a123a", but won't recognize untracking files as deletion

    sos.commit("Second_2")
    _.assertEqual(2, len(os.listdir(branchFolder(1, 1))))  # "a123a" + meta file
    _.assertTrue(os.path.exists("." + os.sep + "file1"))
    _.assertTrue(os.path.exists("." + os.sep + "file2"))

    sos.switch("test")  # go back to first branch - tracks only "file?", but not "a*a"
    _.assertTrue(os.path.exists("." + os.sep + "file1"))
    _.assertTrue(os.path.exists("." + os.sep + "a123a"))  # should not have been touched so far

    sos.update("Other")  # integrate tracked files and tracking pattern from second branch into working state of master branch
    _.assertTrue(os.path.exists("." + os.sep + "file1"))
    _.assertTrue(os.path.exists("." + os.sep + "a123a"))

    _.createFile("axxxa")  # new file that should be tracked on "test" now that we integrated "Other"
    sos.commit("fifth")  # create new revision after integrating updates from second branch
    _.assertEqual(3, len(os.listdir(branchFolder(0, 4))))  # one new file from other branch + one new in current folder + meta file
    sos.switch("Other")  # switch back to just integrated branch that tracks only "a*a" - shouldn't do anything
    _.assertTrue(os.path.exists("." + os.sep + "file1"))
    _.assertTrue(os.path.exists("." + os.sep + "a123a"))
    _.assertFalse(os.path.exists("." + os.sep + "axxxa"))  # because tracked in both branches, but not present in other -> delete in file tree TODO document
    # TODO test switch --meta

  def testLsTracked(_):
    sos.offline("test", options = ["--track"])  # set up repo in tracking mode (SVN- or gitless-style)
    _.createFile(1)
    _.createFile("foo")
    sos.add(".", "./file*")  # capture one file
    sos.ls()
    out = sos.safeSplit(wrapChannels(() -> sos.ls()).replace("\r", ""), "\n")
    _.assertInAny("TRK file1  (file*)", out)
    _.assertNotInAny("... file1  (file*)", out)
    _.assertInAny("... foo", out)
    out = sos.safeSplit(wrapChannels(() -> sos.ls(options = ["--patterns"])).replace("\r", ""), "\n")
    _.assertInAny("TRK file*", out)
    _.createFile("a", prefix = "sub")
    sos.add("sub", "sub/a")
    sos.ls("sub")
    _.assertIn("TRK a  (a)", sos.safeSplit(wrapChannels(() -> sos.ls("sub")).replace("\r", ""), "\n"))

  def testCompression(_):
    _.createFile(1)
    sos.offline("master", options = ["--plain", "--force"])
    _.assertTrue(_.existsFile(branchFolder(0, 0) + os.sep + "b9ee10a87f612e299a6eb208210bc0898092a64c48091327cc2aaeee9b764ffa", b"x" * 10))
    setRepoFlag("compress", True)  # was plain = uncompressed before
    _.createFile(2)
    sos.commit("Added file2")
    _.assertTrue(_.existsFile(branchFolder(0, 1) + os.sep + "03b69bc801ae11f1ff2a71a50f165996d0ad681b4f822df13329a27e53f0fcd2"))  # exists
    _.assertFalse(_.existsFile(branchFolder(0, 1) + os.sep + "03b69bc801ae11f1ff2a71a50f165996d0ad681b4f822df13329a27e53f0fcd2", b"x" * 10))  # but is compressed instead

  def testConfigVariations(_):
    def makeRepo():
      try: os.unlink("file1")
      except: pass
      sos.offline("master", options = ["--plain", "--force"])
      _.createFile(1)
      sos.commit("Added file1")
    sos.config("set", ["strict", "on"])
    makeRepo()
    _.assertTrue(checkRepoFlag("strict", True))
    sos.config("set", ["strict", "off"])
    makeRepo()
    _.assertTrue(checkRepoFlag("strict", False))
    sos.config("set", ["strict", "yes"])
    makeRepo()
    _.assertTrue(checkRepoFlag("strict", True))
    sos.config("set", ["strict", "no"])
    makeRepo()
    _.assertTrue(checkRepoFlag("strict", False))
    sos.config("set", ["strict", "1"])
    makeRepo()
    _.assertTrue(checkRepoFlag("strict", True))
    sos.config("set", ["strict", "0"])
    makeRepo()
    _.assertTrue(checkRepoFlag("strict", False))
    sos.config("set", ["strict", "true"])
    makeRepo()
    _.assertTrue(checkRepoFlag("strict", True))
    sos.config("set", ["strict", "false"])
    makeRepo()
    _.assertTrue(checkRepoFlag("strict", False))
    sos.config("set", ["strict", "enable"])
    makeRepo()
    _.assertTrue(checkRepoFlag("strict", True))
    sos.config("set", ["strict", "disable"])
    makeRepo()
    _.assertTrue(checkRepoFlag("strict", False))
    sos.config("set", ["strict", "enabled"])
    makeRepo()
    _.assertTrue(checkRepoFlag("strict", True))
    sos.config("set", ["strict", "disabled"])
    makeRepo()
    _.assertTrue(checkRepoFlag("strict", False))
    try: sos.config("set", ["strict", "nope"]); _.fail()
    except: pass

  def testLsSimple(_):
    _.createFile(1)
    _.createFile("foo")
    _.createFile("ign1")
    _.createFile("ign2")
    sos.offline("test")  # set up repo in tracking mode (SVN- or gitless-style)
    sos.config("set", ["ignores", "ign1"])  # define an ignore pattern
    sos.config("add", ["ignores", "ign2"])  # define an ignore pattern
    sos.config("set", ["ignoresWhitelist", "ign1;ign2"])  # define a list of ignore patterns
    out = wrapChannels(() -> sos.config("show")).replace("\r", "")
    _.assertIn("ignores => ['ign1', 'ign2']", out)
    out = sos.safeSplit(wrapChannels(() -> sos.ls()).replace("\r", ""), "\n")
    _.assertInAny('... file1', out)
    _.assertInAny('... ign1', out)
    _.assertInAny('... ign2', out)
    try: sos.config("rm", ["foo", "bar"]); _.fail()
    except: pass
    try: sos.config("rm", ["ignores", "foo"]); _.fail()
    except: pass
    sos.config("rm", ["ignores", "ign1"])
    sos.config("unset", ["ignoresWhitelist"])  # remove ignore pattern
    out = sos.safeSplit(wrapChannels(() -> sos.ls()).replace("\r", ""), "\n")
    _.assertInAny('... ign1', out)
    _.assertInAny('IGN ign2', out)
    _.assertNotInAny('... ign2', out)

  def testWhitelist(_):
    # TODO test same for simple mode
    _.createFile(1)
    sos.defaults.ignores[:] = ["file*"]  # replace in-place
    sos.offline("xx", ["--track", "--strict"])  # because nothing to commit due to ignore pattern
    sos.add(".", "./file*")  # add tracking pattern for "file1"
    sos.commit(options = ["--force"])  # attempt to commit the file
    _.assertEqual(1, len(os.listdir(branchFolder(0, 1))))  # only meta data, file1 was ignored
    try: sos.online(); _.fail()  # Exit because dirty
    except: pass  # exception expected
    _.createFile("x2")  # add another change
    sos.add(".", "./x?")  # add tracking pattern for "file1"
    try: sos.online(["--force"]); _.fail()  # force beyond dirty flag check
    except: pass
    sos.online(["--force", "--force"])  # force beyond file tree modifications check
    _.assertFalse(os.path.exists(sos.metaFolder))

    _.createFile(1)
    sos.defaults.ignoresWhitelist[:] = ["file*"]
    sos.offline("xx", ["--track"])
    sos.add(".", "./file*")
    sos.commit()  # should NOT ask for force here
    _.assertEqual(2, len(os.listdir(branchFolder(0, 1))))  # meta data and "file1", file1 was whitelisted

  def testRemove(_):
    _.createFile(1, "x" * 100)
    sos.offline("trunk")
    try: sos.delete("trunk"); _fail()
    except: pass
    _.createFile(2, "y" * 10)
    sos.branch("added")
    sos.delete("trunk")
    _.assertEqual(2, len(os.listdir("." + os.sep + sos.metaFolder)))  # meta data file and "b1"
    _.assertTrue(os.path.exists("." + os.sep + sos.metaFolder + os.sep + "b1"))
    _.assertFalse(os.path.exists("." + os.sep + sos.metaFolder + os.sep + "b0"))
    sos.branch("next")
    _.createFile(3, "y" * 10)  # make a change
    sos.delete("added", "--force")  # should succeed

  def testUsage(_):
    sos.usage()

  def testOnly(_):
    _.assertEqual((f{"./A", "x/B"}, f{"./C"}), sos.parseOnlyOptions(".", ["abc", "def", "--only", "A", "--x", "--only", "x/B", "--except", "C", "--only"]))
    _.assertEqual(f{"B"}, sos.conditionalIntersection(f{"A", "B", "C"}, f{"B", "D"}))
    _.assertEqual(f{"B", "D"}, sos.conditionalIntersection(f{}, f{"B", "D"}))
    _.assertEqual(f{"B", "D"}, sos.conditionalIntersection(None, f{"B", "D"}))
    sos.offline(os.getcwd(), ["--track", "--strict"])
    _.createFile(1)
    _.createFile(2)
    sos.add(".", "./file1")
    sos.add(".", "./file2")
    sos.commit(onlys = f{"./file1"})
    _.assertEqual(2, len(os.listdir(branchFolder(0, 1))))  # only meta and file1
    sos.commit()  # adds also file2
    _.assertEqual(2, len(os.listdir(branchFolder(0, 2))))  # only meta and file1
    _.createFile(1, "cc")  # modify both files
    _.createFile(2, "dd")
    changes = sos.changes(excps = ["./file1"])
    _.assertEqual(1, len(changes.modifications))  # only file2
    _.assertTrue("./file2" in changes.modifications)
    _.assertAllIn(["MOD ./file2", "DIF ./file2"], wrapChannels(() -> sos.diff(onlys = f{"./file2"})))

  def testDiff(_):
    sos.offline(options = ["--strict"])
    _.createFile(1)
    _.createFile(2)
    sos.commit()
    _.createFile(1, "sdfsdgfsdf")
    _.createFile(2, "12343")
    sos.commit()
    _.createFile(1, "foobar")
    _.assertAllIn(["MOD ./file1", "MOD ./file2", "DIF ./file1", "- | 0000 |xxxxxxxxxx|", "+ | 0000 |foobar|"], wrapChannels(() -> sos.diff("/-2")))  # vs. second last
    _.assertNotIn("MOD ./file1", wrapChannels(() -> sos.diff("/-2", onlys = f{"./file2"})))

  def testReorderRenameActions(_):
    result:Tuple[str,str][] = sos.reorderRenameActions([("123", "312"), ("312", "132"), ("321", "123")], exitOnConflict = False)
    _.assertEqual([("312", "132"), ("123", "312"), ("321", "123")], result)
    try: sos.reorderRenameActions([("123", "312"), ("312", "123")], exitOnConflict = True); _.fail()
    except: pass

  def testMove(_):
    sos.offline(options = ["--strict", "--track"])
    _.createFile(1)
    sos.add(".", "./file?")
    # test source folder missing
    try: sos.move("sub", "sub/file?", ".", "?file"); _.fail()
    except: pass
    # test target folder missing: create it
    sos.move(".", "./file?", "sub", "sub/file?")
    _.assertTrue(os.path.exists("sub"))
    _.assertTrue(os.path.exists("sub/file1"))
    _.assertFalse(os.path.exists("file1"))
    # test move
    sos.move("sub", "sub/file?", ".", "./?file")
    _.assertTrue(os.path.exists("1file"))
    _.assertFalse(os.path.exists("sub/file1"))
    # test nothing matches source pattern
    try: sos.move(".", "a*", ".", "b*"); _.fail()
    except: pass
    sos.add(".", "*")  # anything pattern
    try: sos.move(".", "a*", ".", "b*"); _.fail()  # TODO check that alternative pattern "*" was suggested (1 hit)
    except: pass
    # test rename no conflict
    _.createFile(1)
    _.createFile(2)
    _.createFile(3)
    sos.add(".", "./file*")
    sos.config("set", ["ignores", "file3;file4"])  # define an ignore pattern
    sos.config("set", ["ignoresWhitelist", "file3"])
    sos.move(".", "./file*", ".", "fi*le")
    _.assertTrue(all(os.path.exists("fi%dle" % i) for i in range(1, 4)))
    _.assertFalse(os.path.exists("fi4le"))
    # test rename solvable conflicts
    [_.createFile("%s-%s-%s" % tuple(c for c in n)) for n in ["312", "321", "123", "231"]]
#    sos.move("?-?-?")
    # test rename unsolvable conflicts
    # test --soft option
    sos.remove(".", "./?file")  # was renamed before
    sos.add(".", "./?a?b", ["--force"])
    sos.move(".", "./?a?b", ".", "./a?b?", ["--force", "--soft"])
    _.createFile("1a2b")  # should not be tracked
    _.createFile("a1b2")  # should be tracked
    sos.commit()
    _.assertEqual(2, len(os.listdir(branchFolder(0, 1))))
    _.assertTrue(os.path.exists(branchFolder(0, 1) + os.sep + "93b38f90892eb5c57779ca9c0b6fbdf6774daeee3342f56f3e78eb2fe5336c50"))  # a1b2
    _.createFile("1a1b1")
    _.createFile("1a1b2")
    sos.add(".", "?a?b*")
    _.assertIn("not unique", wrapChannels(() -> sos.move(".", "?a?b*", ".", "z?z?")))  # should raise error due to same target name
    # TODO only rename if actually any files are versioned? or simply what is alife?
    # TODO add test if two single question marks will be moved into adjacent characters

  def testFindBase(_):
    old = os.getcwd()
    try:
        os.mkdir("." + os.sep + ".git")
        os.makedirs("." + os.sep + "a" + os.sep + sos.metaFolder)
        os.makedirs("." + os.sep + "a" + os.sep + "b")
        os.chdir("a" + os.sep + "b")
        s, vcs, cmd = sos.findSosVcsBase()
        _.assertIsNotNone(s)
        _.assertIsNotNone(vcs)
        _.assertEqual("git", cmd)
    finally: os.chdir(old)


if __name__ == '__main__':
  logging.basicConfig(level = logging.DEBUG if '-v' in sys.argv or os.getenv("DEBUG", "false").strip().lower() == "true" or os.getenv("CI", "false").strip().lower() == "true" else logging.INFO , stream = sys.stderr, format = "%(asctime)-23s %(levelname)-8s %(name)s:%(lineno)d | %(message)s" if '-v' in sys.argv or os.getenv("DEBUG", "false") == "true" else "%(message)s")
  if configr:
    c = configr.Configr("sos"); c.loadSettings()
    if len(c.keys()) > 0: sos.Exit("Cannot run test suite with existing local SOS user configuration (would affect results)")
  unittest.main(testRunner = debugTestRunner() if '-v' in sys.argv and not os.getenv("CI", "false").lower() == "true" else None)  # warnings = "ignore")
