# Copyright Arne Bachmann
# This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0. If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.

import codecs, doctest, json, logging, os, shutil, sys, time, traceback, unittest, uuid
from io import BytesIO, BufferedRandom, TextIOWrapper

if TYPE_CHECKING:
  from typing import Any, Dict, FrozenSet, List, Set, Tuple, Union
  mock:Any  # to avoid mypy complaint

try: from unittest import mock  # Python 3
except: import mock  # installed via pip

testFolder = os.path.abspath(os.path.join(os.getcwd(), "test", "repo"))  # this needs to be set before the configr and sos imports TODO explain why
rmteFolder = os.path.abspath(os.path.join(os.getcwd(), "test", "remote"))
os.environ["TEST"] = testFolder  # needed to mock configr library calls in sos

import configr
import sos  # import of package, not file (!)

sos.defaults["defaultbranch"] = "trunk"  # because sos.main() is never called
sos.defaults["useChangesCommand"] = True
sos.defaults["useUnicodeFont"] = False
sos.defaults["useColorOutput"] = True


def determineFilesystemTimeResolution() -> float =
  name:str = str(uuid.uuid4())
  with open(name, "w") as fd: fd.write("x")  # create temporary file
  mt:float = os.stat(sos.encode(name)).st_mtime  # get current timestamp
  while os.stat(sos.encode(name)).st_mtime == mt:  # wait until timestamp modified
    time.sleep(0.05)  # to avoid 0.00s bugs (came up some time for unknown reasons)
    with open(name, "w") as fd: fd.write("x")
  mt, start, _count = os.stat(sos.encode(name)).st_mtime, time.time(), 0
  while os.stat(sos.encode(name)).st_mtime == mt:  # now cound and measure time until modified again
    time.sleep(0.05)
    _count += 1
    with open(name, "w") as fd: fd.write("x")
  os.unlink(name)
  fsprecision:float = round(time.time() - start, 2)
  print("File system timestamp precision is %s%.2fs; wrote to the file %d times during that time" % ("probably even higher than " if fsprecision == 0.05 else "", fsprecision, _count))
  fsprecision


FS_PRECISION = determineFilesystemTimeResolution() * 1.55

def sync():
  try: os.sync()  # only Linux  if sys.version_info[:2] >= (3, 3):
  except: time.sleep(FS_PRECISION)  # Windows testing on AppVeyor


def debugTestRunner(post_mortem = None) =
  ''' Unittest runner doing post mortem debugging on failing tests. '''
  import pdb
  if post_mortem is None: post_mortem = pdb.post_mortem
  class DebugTestResult(unittest.TextTestResult):
    def addError(_, test, err):  # called before tearDown()
      traceback.print_exception(*err)
      post_mortem(err[2])
      super(DebugTestResult, _).addError(test, err)
    def addFailure(_, test, err):
      traceback.print_exception(*err)
      post_mortem(err[2])
      super(DebugTestResult, _).addFailure(test, err)
  unittest.TextTestRunner(resultclass = DebugTestResult)

def wrapChannels(func: -> Any) -> str =
  ''' Wrap function call to capture and return strings emitted on stdout and stderr. '''
  oldv, oldso, oldse = sys.argv, sys.stdout, sys.stderr
  class StreamCopyWrapper(TextIOWrapper):
    def __init__(_): TextIOWrapper.__init__(_, BufferedRandom(BytesIO(b"")), encoding = sos.UTF8)
    def write(_, bla): oldso.write(bla); TextIOWrapper.write(_, bla)
  buf = StreamCopyWrapper()
  handler = logging.StreamHandler(buf)  # TODO doesn't seem to be captured
  sys.stdout = sys.stderr = buf  # assignment goes right to left
  logging.getLogger().addHandler(handler)
  try: func()  # capture output into buf
  except Exception as E:  buf.write(str(E) + "\n"); traceback.print_exc(file = buf)
  except SystemExit as F: buf.write("EXIT CODE %s" % F.code + "\n"); traceback.print_exc(file = buf)
  logging.getLogger().removeHandler(handler)
  sys.argv, sys.stdout, sys.stderr = oldv, oldso, oldse  # TODO when run using pythonw.exe and/or no console, these could be None
  buf.seek(0)
  buf.read()

def mockInput(datas:str[], func: () -> Any) -> Any:
  try:  # via python sos/tests.py
    with mock.patch("sos._utility.input", side_effect = datas): return func()
  except:  # via setup.py
    with mock.patch("sos.utility.input", side_effect = datas): return func()

def setRepoFlag(name:str, value:Any, toConfig:bool = False):
  with open(sos.metaFolder + os.sep + sos.metaFile, "r") as fd: flags, branches, config = json.loads(fd.read())
  if not toConfig: flags[name] = value
  else: config[name] = value
  with open(sos.metaFolder + os.sep + sos.metaFile, "w") as fd: fd.write(json.dumps((flags, branches, config)))

def checkRepoFlag(name:str, flag:bool? = None, value:Any? = None) -> bool =
  with open(sos.metaFolder + os.sep + sos.metaFile, "r") as fd: flags, branches, config = json.loads(fd.read())
  (name in flags and flags[name] == flag) if flag is not None else (name in config and config[name] == value)


class Tests(unittest.TestCase):
  ''' Entire test suite. '''

  def setUp(_):
    sos.Metadata.singleton = None
    for folder in (testFolder, rmteFolder):
      for entry in os.listdir(folder):  # cannot reliably remove testFolder on Windows when using TortoiseSVN as VCS
        resource:str = os.path.join(folder, entry)
        shutil.rmtree(sos.encode(resource)) if os.path.isdir(sos.encode(resource)) else os.unlink(sos.encode(resource))
    os.chdir(testFolder)

  # Assertion helpers
  def assertAllIn(_, what:str[], where:Union[str,List[str]], only:bool = False):
    for w in what: _.assertIn(w, where)
    if only: _.assertEqual(len(what), len(where))

  def assertAllNotIn(_, what:str[], where:Union[str,List[str]]):
    for w in what: _.assertNotIn(w, where)

  def assertInAll(_, what:str, where:str[]):
    for w in where: _.assertIn(what, w)

  def assertInAny(_, what:str, where:str[]): _.assertTrue(any(what in w for w in where))

  def assertNotInAny(_, what:str, where:str[]): _.assertFalse(any(what in w for w in where))


  # More helpers
  def createFile(_, number:Union[int,str], contents:str = "x" * 10, prefix:str? = None):
    if prefix and not os.path.exists(prefix): os.makedirs(prefix)
    with open(("." if prefix is None else prefix) + os.sep + (("file%d" % number) if isinstance(number, int) else number), "wb") as fd: fd.write(contents if isinstance(contents, bytes) else contents.encode("cp1252"))
    sync()

  def existsFile(_, number:Union[int, str], expectedContents:bytes = None) -> bool:
    sync()
    if not os.path.exists(("." + os.sep + "file%d" % number) if isinstance(number, int) else number): return False
    if expectedContents is None: return True
    with open(("." + os.sep + "file%d" % number) if isinstance(number, int) else number, "rb") as fd: return fd.read() == expectedContents

  def remoteIsSame(_):
    sync()
    for dirpath, dirnames, filenames in os.walk(os.path.join(testFolder, sos.metaFolder)):
      rmtePath:str = os.path.normpath(os.path.join(rmteFolder, sos.metaFolder, os.path.relpath(dirpath, os.path.join(testFolder, sos.metaFolder))))
      others:List[str] = os.listdir(rmtePath)
      try: _.assertAllIn(dirnames, others);  _.assertAllIn(others, dirnames + filenames)
      except AssertionError as E: raise AssertionError("Mismatch vs. remote: %r\n%r in %s" % (dirnames,  others, dirpath)) from None
      try: _.assertAllIn(filenames, others); _.assertAllIn(others, dirnames + filenames)
      except AssertionError as E: raise AssertionError("Mismatch vs. remote: %r\n% in %sr" % (filenames, others, dirpath)) from None


  # Unit tests
  def testAccessor(_):
    a:Accessor = sos.Accessor({"a": 1})
    _.assertEqual((1, 1), (a["a"], a.a))

  def testCharDet(_):
    _.assertEqual("ascii", sos.detectEncoding(b"abc"))
    _.assertEqual("UTF-8-SIG", sos.detectEncoding("abc".encode("utf-8-sig")))  # with BOM
    _.assertEqual(sos.UTF8, sos.detectEncoding("abcüöä".encode("utf-8")))  # without BOM

  def testTimeString(_):
    _.assertEqual('1500 ms', sos.pure.timeString(1500))
    _.assertEqual('1.5 seconds', sos.pure.timeString(1501))
    _.assertEqual('23.0 hours', sos.pure.timeString(1000*60*60*23))
    _.assertEqual('8.0 days', sos.pure.timeString(1000*60*60*24*8))
    _.assertEqual('1.3 weeks', sos.pure.timeString(1000*60*60*24*9))

  def testUnzip(_):
    a:Tuple[int, str][] = zip([1, 2, 3], ["a", "b", "c"])
    i:Tuple[int]; c:Tuple[str]
    i, c = sos.unzip(a)
    _.assertEqual((1, 2, 3), i)
    _.assertEqual(("a", "b", "c"), c)

  def testUsage(_):
    out = wrapChannels(-> sos.usage.usage("commit"))
    _.assertAllIn(["commit [<message>]  Create a new revision", "Arguments:", "Options:"], out)

  def testIndexing(_):
    m = sos.Metadata()
    m.commits = {}
    _.assertEqual(1, m.correctNegativeIndexing(1))
    _.assertEqual(9999999999999999, m.correctNegativeIndexing(9999999999999999))
    _.assertEqual(0, m.correctNegativeIndexing(0))  # zero always returns zero, even no commits present
    try: m.correctNegativeIndexing(-1); _.fail()
    except SystemExit as E: _.assertEqual(1, E.code)
    m.commits = {0: sos.CommitInfo(0, 0), 1: sos.CommitInfo(1, 0)}
    _.assertEqual(1, m.correctNegativeIndexing(-1))  # zero always returns zero, even no commits present
    _.assertEqual(0, m.correctNegativeIndexing(-2))  # zero always returns zero, even no commits present
    try: m.correctNegativeIndexing(-3); _.fail()
    except SystemExit as E: _.assertEqual(1, E.code)

  def testRestoreFile(_):
    m = sos.Metadata()
    os.makedirs(sos.revisionFolder(0, 0))
    _.createFile("hashed_file", "content", sos.revisionFolder(0, 0))
    m.restoreFile(relPath = "restored", branch = 0, revision = 0, pinfo = sos.PathInfo("hashed_file", 0, (time.time() - 2000) * 1000, "content hash"))
    _.assertTrue(_.existsFile("restored", b""))

  def testGetAnyOfmap(_):
    _.assertEqual(2, sos.getAnyOfMap({"a": 1, "b": 2}, ["x", "b"]))
    _.assertIsNone(sos.getAnyOfMap({"a": 1, "b": 2}, []))

  def testAjoin(_):
    _.assertEqual("a1a2", sos.ajoin("a", ["1", "2"]))
    _.assertEqual("* a\n* b", sos.ajoin("* ", ["a", "b"], "\n"))

  def testFindChanges(_):
    m = sos.Metadata(os.getcwd())
    try: sos.config(["set", "texttype", "*"])
    except SystemExit as E: _.assertEqual(0, E.code)
    try: sos.config(["set", "ignores", "test/*.cfg;D:\\apps\\*.cfg.bak"])  # will be stripped from leading paths anyway
    except SystemExit as E: _.assertEqual(0, E.code)
    m = sos.Metadata(os.getcwd())  # reload from file system
    for file in [f for f in os.listdir() if f.endswith(".bak")]: os.unlink(file)  # remove configuration file
    _.createFile(9, b"")
    _.createFile(1, "1")
    m.createBranch(0)
    _.assertEqual(2, len(m.paths))
    time.sleep(FS_PRECISION)  # time required by filesystem time resolution issues
    _.createFile(1, "2")  # modify existing file
    _.createFile(2, "2")  # add another file
    m.loadCommit(0, 0)
    changes, msg = m.findChanges()  # detect time skew
    _.assertEqual(1, len(changes.additions))
    _.assertEqual(0, len(changes.deletions))
    _.assertEqual(1, len(changes.modifications))
    _.assertEqual(0, len(changes.moves))
    m.paths.update(changes.additions)
    m.paths.update(changes.modifications)
    _.createFile(2, "12")  # modify file again
    changes, msg = m.findChanges(0, 1)  # by size, creating new commit
    _.assertEqual(0, len(changes.additions))
    _.assertEqual(0, len(changes.deletions))
    _.assertEqual(1, len(changes.modifications))
    _.assertEqual(0, len(changes.moves))
    _.assertTrue(os.path.exists(sos.revisionFolder(0, 1)))
    _.assertTrue(os.path.exists(sos.revisionFolder(0, 1, file = "03b69bc801ae11f1ff2a71a50f165996d0ad681b4f822df13329a27e53f0fcd2")))
    # TODO test moves

  def testDumpSorting(_):
    m:Metadata = sos.Metadata()
    _.createFile(1)
    sos.offline()
    _.createFile(2)
    _.createFile(3)
    sos.commit()
    _.createFile(4)
    _.createFile(5)
    sos.commit()
    out:List[str] = [__.replace(os.getcwd() + os.sep + sos.metaFolder + os.sep, "").strip() for __ in wrapChannels(-> sos.dump("x." + sos.DUMP_FILE)).replace("\r", "").split("\n")]
    _.assertTrue(out.index("b0%sr2" % os.sep) > out.index("b0%sr1" % os.sep))
    _.assertTrue(out.index("b0%sr1" % os.sep) > out.index("b0%sr0" % os.sep))

  def testFitStrings(_):
    a:List[str] = ["a", "a" * 6, "a" * 15]
    _.assertEqual('pre "a" "aaaaaa"', sos.fitStrings(a, "pre", length = 20))
    _.assertEqual('pre "aaaaaaaaaaaaaaa"', sos.fitStrings(a, "pre", length = 25))
  def testMoves(_):
    _.createFile(1, "1")
    _.createFile(2, "2", "sub")
    sos.offline(options = ["--strict", "--compress"])  # TODO move compress flag to own test function and check if it actually works
    os.renames(sos.encode("." + os.sep + "file1"), sos.encode("sub" + os.sep + "file1"))
    os.renames(sos.encode("sub" + os.sep + "file2"), sos.encode("." + os.sep + "file2"))
    out:str = wrapChannels(-> sos.changes())
    _.assertIn("MOV ./file2  <-  sub/file2", out)
    _.assertIn("MOV sub/file1  <-  ./file1", out)
    out = wrapChannels(-> sos.changes(options = ["--relative"], cwd = "sub"))
    _.assertIn("MOV ..%sfile2  <-  file2" % os.sep, out)  # no ./ for relative OS-specific paths
    _.assertIn("MOV file1  <-  ..%sfile1" % os.sep, out)
    out = wrapChannels(-> sos.commit())
    _.assertIn("MOV ./file2  <-  sub/file2", out)
    _.assertIn("MOV sub/file1  <-  ./file1", out)
    _.assertAllIn(["Created new revision r01", "summing 628 bytes in 2 files (88.22% SOS overhead)"], out)  # TODO why is this not captured?

  def testPatternPaths(_):
    sos.offline(options = ["--track"])
    os.mkdir("sub")
    _.createFile("sub" + os.sep + "file1", "sdfsdf")
    out:str = wrapChannels(-> sos.add(["sub"], ["sub/file?"]))
    _.assertAllIn(["Added tracking pattern", "'%s'" % "file?", os.path.abspath("sub")], out)
    sos.commit("test")  # should pick up sub/file1 pattern
    _.assertEqual(2, len(os.listdir(sos.revisionFolder(0, 1))))  # sub/file1 was added
    _.createFile(1)
    try: sos.commit("nothing"); _.fail()  # should not commit anything, as the file in base folder doesn't match the tracked pattern
    except: pass

  def testNoArgs(_):
    pass   # call "sos" without arguments should simply show help or info about missing arguments

  def testAutoMetadataUpgrade(_):
    sos.offline()
    with codecs.open(sos.encode(os.path.join(sos.metaFolder, sos.metaFile)), "r", encoding = sos.UTF8) as fd: repo, branches, config = json.load(fd)
    repo["version"] = None  # lower than any pip version
    branches[:] = [branch[:5] for branch in branches]  # simulate some older state
    del repo["format"]  # simulate pre-1.3.5
    with codecs.open(sos.encode(os.path.join(sos.metaFolder, sos.metaFile)), "w", encoding = sos.UTF8) as fd: json.dump((repo, branches, config), fd, ensure_ascii = False)
    out:str = wrapChannels(-> sos.status(options = ["--repo"]))
    _.assertAllIn(["pre-1.2", "Upgraded repository metadata to match SOS version '2018.1210.3028'", "Upgraded repository metadata to match SOS version '1.3.5'"], out)

  def testFastBranching(_):
    _.createFile(1)
    out:str = wrapChannels(-> sos.offline(options = ["--strict", "--verbose"]))  # b0/r0 = ./file1
    _.assertIn("1 file added to initial branch 'trunk'", out)
    _.createFile(2)
    os.unlink("file1")
    sos.commit()  # b0/r1 = +./file2  -./file1
    sos.branch(options = ["--fast", "--last"])  # branch b1 from b0/1 TODO modify option switch once --fast becomes the new normal
    _.assertAllIn([sos.metaFile, sos.metaBack, "b0", "b1"], os.listdir(sos.metaFolder), only = True)
    _.createFile(3)
    sos.commit()  # b1/r2 = ./file2, ./file3
    _.assertAllIn([sos.metaFile, sos.metaBack, "r2"], os.listdir(sos.branchFolder(1)), only = True)
    sos.branch(options = ["--fast", "--last"])  # branch b2 from b1/2
    sos.destroy("0")  # remove parent of b1 and transitive parent of b2
    _.assertAllIn([sos.metaFile, sos.metaBack, "b0_last", "b1", "b2"], os.listdir(sos.metaFolder), only = True)  # branch 0 was removed
    _.assertAllIn([sos.metaFile, sos.metaBack, "r0", "r1", "r2"], os.listdir(sos.branchFolder(1)), only = True)  # all revisions before branch point were copied to branch 1
    _.assertAllIn([sos.metaFile, sos.metaBack, "r0", "r1", "r2"], os.listdir(sos.branchFolder(2)), only = True)
    # TODO test also other functions like status --repo, log

  def testModificationWithOldRevisionRecognition(_):
    now:float = time.time()
    _.createFile(1)
    sync()
    sos.offline(options = ["--strict"])
    _.createFile(1, "abc")  # modify contents
    os.utime(sos.encode("file1"), (now - 2000, now - 2000))  # make it look like an older version
    sync()
    out:str = wrapChannels(-> sos.changes())
    _.assertIn("<older than previously committed>", out)
    out = wrapChannels(-> sos.commit())
    _.assertIn("<older than previously committed>", out)

  def testGetParentBranch(_):
    m = sos.Accessor({"branches": {0: sos.Accessor({"parent": None, "revision": None}), 1: sos.Accessor({"parent": 0, "revision": 1})}, "getParentBranches": lambda b, r: sos.Metadata.getParentBranches(m, b, r)})  # stupid workaround for the self-reference in the implementation
    _.assertEqual(0, sos.Metadata.getParentBranch(m, 1, 0))
    _.assertEqual(0, sos.Metadata.getParentBranch(m, 1, 1))
    _.assertEqual(1, sos.Metadata.getParentBranch(m, 1, 2))
    _.assertEqual(0, sos.Metadata.getParentBranch(m, 0, 10))

  def testTokenizeGlobPattern(_):
    _.assertEqual([], sos.tokenizeGlobPattern(""))
    _.assertEqual([sos.GlobBlock(False, "*", 0)], sos.tokenizeGlobPattern("*"))
    _.assertEqual([sos.GlobBlock(False, "*", 0), sos.GlobBlock(False, "???", 1)], sos.tokenizeGlobPattern("*???"))
    _.assertEqual([sos.GlobBlock(True, "x", 0),  sos.GlobBlock(False, "*", 1),  sos.GlobBlock(True, "x", 2)], sos.tokenizeGlobPattern("x*x"))
    _.assertEqual([sos.GlobBlock(True, "x", 0),  sos.GlobBlock(False, "*", 1),  sos.GlobBlock(False, "??", 2), sos.GlobBlock(False, "*", 4), sos.GlobBlock(True, "x", 5)], sos.tokenizeGlobPattern("x*??*x"))
    _.assertEqual([sos.GlobBlock(False, "?", 0), sos.GlobBlock(True, "abc", 1), sos.GlobBlock(False, "*", 4)], sos.tokenizeGlobPattern("?abc*"))

  def testTokenizeGlobPatterns(_):
    try: sos.tokenizeGlobPatterns("x*x", "x*"); _.fail()  # because number of literal strings differs
    except: pass
    try: sos.tokenizeGlobPatterns("x*", "x?"); _.fail()  # because glob patterns differ
    except: pass
    try: sos.tokenizeGlobPatterns("x*", "?x"); _.fail()  # glob patterns differ, regardless of position
    except: pass
    sos.tokenizeGlobPatterns("x*", "*x")  # succeeds, because glob patterns match (differ only in position)
    sos.tokenizeGlobPatterns("*xb?c", "*x?bc")  # succeeds, because glob patterns match (differ only in position)
    try: sos.tokenizeGlobPatterns("a???b*", "ab???*"); _.fail()  # succeeds, because glob patterns match (differ only in position)
    except: pass

  def testConvertGlobFiles(_):
    _.assertEqual(["xxayb", "aacb"], [r[1] for r in sos.convertGlobFiles(["axxby", "aabc"], *sos.tokenizeGlobPatterns("a*b?", "*a?b"))])
    _.assertEqual(["1qq2ww3", "1abcbx2xbabc3"], [r[1] for r in sos.convertGlobFiles(["qqxbww", "abcbxxbxbabc"], *sos.tokenizeGlobPatterns("*xb*", "1*2*3"))])

  def testFolderRemove(_):
    m = sos.Metadata(os.getcwd())
    _.createFile(1)
    _.createFile("a", prefix = "sub")
    sos.offline()
    _.createFile(2)
    os.unlink("sub" + os.sep + "a")
    os.rmdir("sub")
    changes = sos.changes()  # TODO #254 replace by output check
    _.assertEqual(1, len(changes.additions))
    _.assertEqual(0, len(changes.modifications))
    _.assertEqual(1, len(changes.deletions))
    _.createFile("a", prefix = "sub")
    changes = sos.changes()
    _.assertEqual(0, len(changes.deletions))

  def testSwitchConflict(_):
    sos.offline(options = ["--strict"])  # (r0)
    _.createFile(1)
    sos.commit()  # add file (r1)
    os.unlink("file1")
    sos.commit()  # remove (r2)
    _.createFile(1, "something else")
    sos.commit() # (r3)
    sos.switch("/1")  # updates file1 - marked as MOD, because mtime was changed
    _.existsFile(1, "x" * 10)
    sos.switch("/2", ["--force"])  # remove file1 requires --force, because size/content (or mtime in non-strict mode) is different to head of branch
    sos.switch("/0")  # do nothing, as file1 is already removed
    sos.switch("/1")  # add file1 back
    sos.switch("/", ["--force"])  # requires force because changed vs. head of branch
    _.existsFile(1, "something else")

  def testComputeSequentialPathSet(_):
    os.makedirs(sos.revisionFolder(0, 0))
    os.makedirs(sos.revisionFolder(0, 1))
    os.makedirs(sos.revisionFolder(0, 2))
    os.makedirs(sos.revisionFolder(0, 3))
    os.makedirs(sos.revisionFolder(0, 4))
    m = sos.Metadata(os.getcwd())
    m.branch = 0
    m.commit = 2
    m.saveBranches()
    m.paths = {"./a": sos.PathInfo("", 0, 0, "")}
    m.saveCommit(0, 0)  # initial
    m.paths["./a"] = sos.PathInfo("", 1, 0, "")
    m.saveCommit(0, 1)  # mod
    m.paths["./b"] = sos.PathInfo("", 0, 0, "")
    m.saveCommit(0, 2)  # add
    m.paths["./a"] = sos.PathInfo("", None, 0, "")
    m.saveCommit(0, 3)  # del
    m.paths["./a"] = sos.PathInfo("", 2, 0, "")
    m.saveCommit(0, 4)  # readd
    m.commits = {i: sos.CommitInfo(i, 0, None) for i in range(5)}
    m.saveBranch(0)
    m.branches = {0: sos.BranchInfo(0, 0), 1: sos.BranchInfo(1, 0)}
    m.saveBranches()
    m.computeSequentialPathSet(0, 4)
    _.assertEqual(2, len(m.paths))

  def testParseRevisionString(_):
    m = sos.Metadata(os.getcwd())
    m.branch = 1
    m.commits = {0: 0, 1:1, 2:2}
    _.assertEqual((1, 3), m.parseRevisionString("3"))
    _.assertEqual((2, 3), m.parseRevisionString("2/3"))
    _.assertEqual((1, -1), m.parseRevisionString(None))
    _.assertEqual((None, None), m.parseRevisionString(""))
    _.assertEqual((2, -1), m.parseRevisionString("2/"))
    _.assertEqual((1, -2), m.parseRevisionString("/-2"))
    _.assertEqual((1, -1), m.parseRevisionString("/"))

  def testOfflineEmpty(_):
    os.mkdir("." + os.sep + sos.metaFolder)
    try: sos.offline("trunk"); _.fail()
    except SystemExit as E: _.assertEqual(1, E.code)
    os.rmdir("." + os.sep + sos.metaFolder)
    sos.offline("test")
    _.assertIn(sos.metaFolder, os.listdir("."))
    _.assertAllIn(["b0", sos.metaFile], os.listdir("." + os.sep + sos.metaFolder))
    _.assertAllIn(["r0", sos.metaFile], os.listdir("." + os.sep + sos.metaFolder + os.sep + "b0"))
    _.assertEqual(2, len(os.listdir("." + os.sep + sos.metaFolder)))  # only branch folder and meta data file
    _.assertEqual(2, len(os.listdir("." + os.sep + sos.metaFolder + os.sep + "b0")))  # only commit folder and meta data file
    _.assertEqual(1, len(os.listdir(sos.revisionFolder(0, 0))))  # only meta data file

  def testOfflineWithFiles(_):
    _.createFile(1, "x" * 100)
    _.createFile(2)
    sos.offline("test")
    _.assertAllIn(["file1", "file2", sos.metaFolder], os.listdir("."))
    _.assertAllIn(["b0", sos.metaFile], os.listdir("." + os.sep + sos.metaFolder))
    _.assertAllIn(["r0", sos.metaFile], os.listdir("." + os.sep + sos.metaFolder + os.sep + "b0"))
    _.assertAllIn([sos.metaFile, "03b69bc801ae11f1ff2a71a50f165996d0ad681b4f822df13329a27e53f0fcd2", "b9ee10a87f612e299a6eb208210bc0898092a64c48091327cc2aaeee9b764ffa"], os.listdir("." + os.sep + sos.metaFolder + os.sep + "b0" + os.sep + "r0"))
    _.assertEqual(2, len(os.listdir("." + os.sep + sos.metaFolder)))  # only branch folder and meta data file
    _.assertEqual(2, len(os.listdir("." + os.sep + sos.metaFolder + os.sep + "b0")))  # only commit folder and meta data file
    _.assertEqual(3, len(os.listdir(sos.revisionFolder(0, 0))))  # only meta data file plus branch base file copies

  def testBranch(_):
    _.createFile(1, "x" * 100)
    _.createFile(2)
    sos.offline("test")  # b0/r0
    sos.branch("other")  # b1/r0
    _.assertAllIn(["b0", "b1", sos.metaFile], os.listdir("." + os.sep + sos.metaFolder))
    _.assertEqual(list(sorted(os.listdir("." + os.sep + sos.metaFolder + os.sep + "b0"))),
                  list(sorted(os.listdir("." + os.sep + sos.metaFolder + os.sep + "b1"))))
    _.assertEqual(list(sorted(os.listdir(sos.revisionFolder(0, 0)))),
                  list(sorted(os.listdir(sos.revisionFolder(1, 0)))))
    _.createFile(1, "z")  # modify file
    sos.branch()  # b2/r0  branch to unnamed branch with modified file tree contents
    _.assertNotEqual(os.stat(sos.encode("." + os.sep + sos.metaFolder + os.sep + "b1" + os.sep + "r0" + os.sep + "b9ee10a87f612e299a6eb208210bc0898092a64c48091327cc2aaeee9b764ffa")).st_size,
                     os.stat(sos.encode("." + os.sep + sos.metaFolder + os.sep + "b2" + os.sep + "r0" + os.sep + "b9ee10a87f612e299a6eb208210bc0898092a64c48091327cc2aaeee9b764ffa")).st_size)
    _.createFile(3, "z")
    sos.branch("from_last_revision", options = ["--last", "--stay"])  # b3/r0 create copy of other file1,file2 and don't switch
    _.assertEqual(list(sorted(os.listdir("." + os.sep + sos.metaFolder + os.sep + "b3" + os.sep + "r0"))),
                  list(sorted(os.listdir("." + os.sep + sos.metaFolder + os.sep + "b2" + os.sep + "r0"))))
    # Check sos.status output which branch is marked


  def testComittingAndChanges(_):
    _.createFile(1, "x" * 100)
    _.createFile(2)
    sos.offline("test")
    changes = sos.changes()
    _.assertEqual(0, len(changes.additions))
    _.assertEqual(0, len(changes.deletions))
    _.assertEqual(0, len(changes.modifications))
    _.createFile(1, "z")  # size change
    changes = sos.changes()
    _.assertEqual(0, len(changes.additions))
    _.assertEqual(0, len(changes.deletions))
    _.assertEqual(1, len(changes.modifications))
    sos.commit("message")
    _.assertAllIn(["r0", "r1", sos.metaFile], os.listdir("." + os.sep + sos.metaFolder + os.sep + "b0"))
    _.assertAllIn([sos.metaFile, "b9ee10a87f612e299a6eb208210bc0898092a64c48091327cc2aaeee9b764ffa"], os.listdir(sos.revisionFolder(0, 1)))
    _.assertEqual(2, len(os.listdir(sos.revisionFolder(0, 1))))  # no further files, only the modified one
    _.assertEqual(1, len(sos.changes("/0").modifications))  # vs. explicit revision on current branch
    _.assertEqual(1, len(sos.changes("0/0").modifications))  # vs. explicit branch/revision
    _.createFile(1, "")  # modify to empty file, mentioned in meta data, but not stored as own file
    os.unlink("file2")
    changes = sos.changes()
    _.assertEqual(0, len(changes.additions))
    _.assertEqual(1, len(changes.deletions))
    _.assertEqual(1, len(changes.modifications))
    sos.commit("modified")
    _.assertEqual(1, len(os.listdir(sos.revisionFolder(0, 2))))  # no additional files, only mentions in metadata
    try: sos.commit("nothing"); _.fail()  # expecting Exit due to no changes
    except: pass

  def testGetBranch(_):
    m = sos.Metadata(os.getcwd())
    m.branch = 1  # current branch
    m.branches = {0: sos.BranchInfo(0, 0, "trunk")}
    _.assertEqual(27, m.getBranchByName(27))
    _.assertEqual(0, m.getBranchByName("trunk"))
    _.assertEqual(1, m.getBranchByName(""))  # split from "/"
    _.assertIsNone(m.getBranchByName("unknown"))
    m.commits = {0: sos.CommitInfo(0, 0, "bla")}
    _.assertEqual(13, m.getRevisionByName("13"))
    _.assertEqual(0, m.getRevisionByName("bla"))
    _.assertEqual(-1, m.getRevisionByName(""))  # split from "/"

  def testTagging(_):
    m = sos.Metadata(os.getcwd())
    sos.offline()
    _.createFile(111)
    sos.commit("tag", ["--tag"])
    out:str = wrapChannels(-> sos.log()).replace("\r", "").split("\n")
    _.assertTrue(any("|tag" in line and line.endswith("|%sTAG%s" % (sos.Fore.MAGENTA, sos.Fore.RESET)) for line in out))
    _.createFile(2)
    try: sos.commit("tag"); _.fail()
    except: pass
    sos.commit("tag-2", ["--tag"])
    out = wrapChannels(-> sos.ls(options = ["--tags"])).replace("\r", "")
    _.assertIn("TAG tag", out)

  def testSwitch(_):
    try: shutil.rmtree(os.path.join(rmteFolder, sos.metaFolder))
    except: pass
    _.createFile(1, "x" * 100)
    _.createFile(2, "y")
    sos.offline("test", remotes = [rmteFolder])  # file1-2  in initial branch commit
    sos.branch("second")  # file1-2  switch, having same files
    sos.switch("0")  # no change, switch back, no problem
    sos.switch("second")  # no change  # switch back, no problem
    _.createFile(3, "y")  # generate a file
    try: sos.switch("test"); _.fail()  # uncommited changes detected
    except SystemExit as E: _.assertEqual(1, E.code)
    sos.commit("Finish")  # file1-3  commit third file into branch second
    sos.changes()
    sos.switch("test")  # file1-2, remove file3 from file tree
    _.assertFalse(_.existsFile(3))  # removed when switching back to test
    _.createFile("XXX")
    out:str = wrapChannels(-> sos.status()).replace("\r", "")
    _.assertIn("File tree has changes", out)
    _.assertNotIn("File tree is unchanged", out)
    _.assertIn("  * b0   'test'", out)
    _.assertIn("    b1 'second'", out)
    _.assertIn("modified", out)  # one branch has commits
    _.assertIn("in sync", out)  # the other doesn't
    sos.defaults["useChangesCommand"] = False  # because sos.main() is never called
    out = wrapChannels(-> sos.status()).replace("\r", "")  # trigger repo info
    _.assertAllIn(["Metadata format", "Content checking:    %ssize & timestamp" % sos.Fore.BLUE, "Data compression:    %sdeactivated" % sos.Fore.BLUE, "Repository mode:     %ssimple" % sos.Fore.GREEN, "Number of branches:  2"], out)
    sos.defaults["useChangesCommand"] = True  # because sos.main() is never called
    _.createFile(4, "xy")  # generate a file
    sos.switch("second", ["--force"])  # avoids warning on uncommited changes, but keeps file4
    _.assertFalse(_.existsFile(4))  # removed when forcedly switching back to test
    _.assertTrue(_.existsFile(3))  # was restored from branch's revision r1
    os.unlink("." + os.sep + "file1")  # remove old file1
    sos.switch("test", ["--force"])  # should restore file1 and remove file3
    _.assertTrue(_.existsFile(1))  # was restored from branch's revision r1
    _.assertFalse(_.existsFile(3))  # was restored from branch's revision r1
    sos.verbose.append(None)  # dict access necessary, as references on module-top-level are frozen
    out = wrapChannels(-> sos.dump("dumped.sos.zip", options = ["--skip-backup", "--full"])).replace("\r", "")
    _.assertAllIn(["Dumping revisions"], out)  # TODO cannot set verbose flag afer module loading. Use transparent wrapper instead
    _.assertNotIn("Creating backup", out)
    out = wrapChannels(-> sos.dump("dumped.sos.zip", options = ["--skip-backup"])).replace("\r", "")
    _.assertIn("Dumping revisions", out)
    _.assertNotIn("Creating backup", out)
    out = wrapChannels(-> sos.dump("dumped.sos.zip", options = ["--full"])).replace("\r", "")
    _.assertAllIn(["Creating backup"], out)
    _.assertIn("Dumping revisions", out)
    sos.verbose.pop()
    _.remoteIsSame()
    os.chdir(rmteFolder)
    try: sos.status()
    except SystemExit as E: _.assertEqual(1, E.code)

  def testAutoDetectVCS(_):
    os.mkdir(".git")
    sos.offline(sos.vcsBranches[sos.findSosVcsBase()[2]])  # create initial branch
    with open(sos.metaFolder + os.sep + sos.metaFile, "r") as fd: meta = fd.read()
    _.assertTrue("\"master\"" in meta)
    os.rmdir(".git")

  def testNoRemotes(_):
    sos.offline(remotes = [rmteFolder])
    _.createFile(1)
    sos.commit(options = ["--no-remotes"])
    _.assertTrue(_.existsFile(sos.revisionFolder(0, 1, file = "b9ee10a87f612e299a6eb208210bc0898092a64c48091327cc2aaeee9b764ffa")))
    _.assertFalse(_.existsFile(os.path.join(sos.branchFolder(0, rmteFolder), "r%d" % 1, "b9ee10a87f612e299a6eb208210bc0898092a64c48091327cc2aaeee9b764ffa")))

  def testUpdate(_):
    sos.offline("trunk")  # create initial branch b0/r0
    _.createFile(1, "x" * 100)
    sos.commit("second")  # create b0/r1

    sos.switch("/0")  # go back to b0/r0 - deletes file1
    _.assertFalse(_.existsFile(1))

    sos.update("/1")  # recreate file1
    _.assertTrue(_.existsFile(1))

    sos.commit("third", ["--force"])  # force because nothing to commit. should create r2 with same contents as r1, but as differential from r1, not from r0 (= no changes in meta folder)
    _.assertTrue(os.path.exists(sos.revisionFolder(0, 2)))
    _.assertTrue(os.path.exists(sos.revisionFolder(0, 2, file = sos.metaFile)))
    _.assertEqual(1, len(os.listdir(sos.revisionFolder(0, 2))))  # only meta data file, no differential files

    sos.update("/1")  # do nothing, as nothing has changed
    _.assertTrue(_.existsFile(1))

    _.createFile(2, "y" * 100)
#    out:str = wrapChannels(-> sos.branch("other"))  # won't comply as there are changes
#    _.assertIn("--force", out)
    sos.branch("other", options = ["--force"])  # automatically including file 2 (as we are in simple mode)
    _.assertTrue(_.existsFile(2))
    sos.update("trunk", ["--add"])  # only add stuff
    _.assertTrue(_.existsFile(2))
    sos.update("trunk")  # nothing to do
    _.assertFalse(_.existsFile(2))  # removes file not present in original branch

    theirs = b"a\nb\nc\nd\ne\nf\ng\nh\nx\nx\nj\nk"
    _.createFile(10, theirs)
    mine = b"a\nc\nd\ne\ng\nf\nx\nh\ny\ny\nj"  # missing "b", inserted g, modified g->x, replace x/x -> y/y, removed k
    _.createFile(11, mine)
    _.assertEqual((b"a\nb\nc\nd\ne\nf\ng\nh\nx\nx\nj\nk", b"\n"), sos.merge(filename = "." + os.sep + "file10", intoname = "." + os.sep + "file11", mergeOperation = sos.MergeOperation.BOTH))  # completely recreated other file
    _.assertEqual((b'a\nb\nc\nd\ne\ng\nf\ng\nh\ny\ny\nx\nx\nj\nk', b"\n"), sos.merge(filename = "." + os.sep + "file10", intoname = "." + os.sep + "file11", mergeOperation = sos.MergeOperation.INSERT))

  def testUpdate2(_):
    _.createFile("test.txt", "x" * 10)
    sos.offline("trunk", ["--strict"])  # use strict mode, as timestamp differences are too small for testing
    sync()
    sos.branch("mod")
    _.createFile("test.txt", "x" * 5 + "y" * 5)
    sos.commit("mod")  # create b0/r1
    sos.switch("trunk", ["--force"])  # should replace contents, force in case some other files were modified (e.g. during working on the code) TODO investigate more
    _.assertTrue(_.existsFile("test.txt", b"x" * 10))
    sos.update("mod")  # integrate changes TODO same with ask -> theirs
    _.existsFile("test.txt", b"x" * 5 + b"y" * 5)
    _.createFile("test.txt", "x" * 10)
    mockInput(["t"], -> sos.update("mod", ["--ask-lines"]))
    sync()
    _.assertTrue(_.existsFile("test.txt", b"x" * 5 + b"y" * 5))
    _.createFile("test.txt", "x" * 5 + "z" + "y" * 4)
    sos.update("mod")  # auto-insert/removes (no intra-line conflict)
    _.createFile("test.txt", "x" * 5 + "z" + "y" * 4)
    sync()
    mockInput(["t"], -> sos.update("mod", ["--ask"]))  # same as above with interaction -> use theirs (overwrite current file state)
    _.assertTrue(_.existsFile("test.txt", b"x" * 5 + b"y" * 5))

  def testIsTextType(_):
    m = sos.Metadata(".")
    m.c.texttype = ["*.x", "*.md", "*.md.*"]
    m.c.bintype = ["*.md.confluence"]
    _.assertTrue(m.isTextType("ab.txt"))
    _.assertTrue(m.isTextType("./ab.txt"))
    _.assertTrue(m.isTextType("bc/ab.txt"))
    _.assertFalse(m.isTextType("bc/ab."))
    _.assertTrue(m.isTextType("23_3.x.x"))
    _.assertTrue(m.isTextType("dfg/dfglkjdf7/test.md"))
    _.assertTrue(m.isTextType("./test.md.pdf"))
    _.assertFalse(m.isTextType("./test_a.md.confluence"))

  def testEolDet(_):
    ''' Check correct end-of-line detection. '''
    _.assertEqual(b"\n", sos.eoldet(b"a\nb"))
    _.assertEqual(b"\r\n", sos.eoldet(b"a\r\nb\r\n"))
    _.assertEqual(b"\r", sos.eoldet(b"\ra\rb"))
    _.assertAllIn(["Inconsistent", "with "], wrapChannels(() -> _.assertEqual(b"\n", sos.eoldet(b"\r\na\r\nb\n"))))
    _.assertAllIn(["Inconsistent", "without"], wrapChannels(() -> _.assertEqual(b"\n", sos.eoldet(b"\ra\nnb\n"))))
    _.assertIsNone(sos.eoldet(b""))
    _.assertIsNone(sos.eoldet(b"sdf"))

  def testMergeClassic(_):
    _.createFile(1, contents = b"abcdefg")
    b:bytes = b"iabcxeg"
    _.assertEqual.__self__.maxDiff = None  # to get a full diff
    out:str = wrapChannels(-> sos.mergeClassic(b, "file1", "from", "to", 24523234, 1))
    try: _.assertAllIn(["*** from\tThu Jan  1 07:48:43 1970", "! iabcxeg", "! abcdefg"], out)
    except: _.assertAllIn(["*** from\tThu Jan  1 06:48:43 1970", "! iabcxeg", "! abcdefg"], out)  # differing local time on CI system TODO make this better

  def testMerge(_):
    ''' Check merge results depending on user options. '''
    a:bytes = b"a\nb\ncc\nd"
    b:bytes = b"a\nb\nee\nd"  # replaces cc by ee
    _.assertEqual(b"a\nb\ncc\nd", sos.merge(a, b, mergeOperation = sos.MergeOperation.INSERT)[0])  # one-line block replacement using lineMerge
    _.assertEqual(b"a\nb\neecc\nd", sos.merge(a, b, mergeOperation = sos.MergeOperation.INSERT, charMergeOperation = sos.MergeOperation.INSERT)[0])  # means insert changes from a into b, but don't replace
    _.assertEqual(b"a\nb\n\nd", sos.merge(a, b, mergeOperation = sos.MergeOperation.INSERT, charMergeOperation = sos.MergeOperation.REMOVE)[0])  # means insert changes from a into b, but don't replace
    _.assertEqual(b"a\nb\ncc\nd", sos.merge(a, b, mergeOperation = sos.MergeOperation.REMOVE)[0])  # one-line block replacement using lineMerge
    _.assertEqual(b"a\nb\n\nd", sos.merge(a, b, mergeOperation = sos.MergeOperation.REMOVE, charMergeOperation = sos.MergeOperation.REMOVE)[0])
    _.assertEqual(a, sos.merge(a, b, mergeOperation = sos.MergeOperation.BOTH)[0])  # keeps any changes in b
    a = b"a\nb\ncc\nd"
    b = b"a\nb\nee\nf\nd"  # replaces cc by block of two lines ee, f
    _.assertEqual(b"a\nb\nee\nf\ncc\nd", sos.merge(a, b, mergeOperation = sos.MergeOperation.INSERT)[0])  # multi-line block replacement
    _.assertEqual(b"a\nb\nd",         sos.merge(a, b, mergeOperation = sos.MergeOperation.REMOVE)[0])
    _.assertEqual(a, sos.merge(a, b, mergeOperation = sos.MergeOperation.BOTH)[0])  # keeps any changes in b
    # Test with change + insert
    _.assertEqual(b"a\nb fdcd d\ne", sos.merge(b"a\nb cd d\ne", b"a\nb fdd d\ne", charMergeOperation = sos.MergeOperation.INSERT)[0])
    _.assertEqual(b"a\nb d d\ne",  sos.merge(b"a\nb cd d\ne", b"a\nb fdd d\ne", charMergeOperation = sos.MergeOperation.REMOVE)[0])
    # Test interactive merge
    a = b"a\nb\nb\ne"  # block-wise replacement
    b = b"a\nc\ne"
    _.assertEqual(b, mockInput(["i"], -> sos.merge(a, b, mergeOperation = sos.MergeOperation.ASK)[0]))
    _.assertEqual(a, mockInput(["t"], -> sos.merge(a, b, mergeOperation = sos.MergeOperation.ASK)[0]))
    a = b"a\nb\ne"  # intra-line merge
    _.assertEqual(b, mockInput(["i"], -> sos.merge(a, b, charMergeOperation = sos.MergeOperation.ASK)[0]))
    _.assertEqual(a, mockInput(["t"], -> sos.merge(a, b, charMergeOperation = sos.MergeOperation.ASK)[0]))
    _.assertEqual(b"aabaacaaa", sos.merge(b"aabaacaaa", b"aaaacaaa")[0])
    _.assertEqual(b"aabaacaaa", sos.merge(b"aabaacaaa", b"aaaaaaa")[0])
    _.assertEqual(b"aabaacaaa", sos.merge(b"aabaacaaa", b"aabaacaaaa")[0])
    _.assertEqual(b"aabaacaaa", sos.merge(b"aabaacaaa", b"xaaaadaaac")[0])

  def testMergeEol(_):
    _.assertEqual(b"\r\n", sos.merge(b"a\nb", b"a\r\nb")[1])
    _.assertIn("Differing EOL-styles", wrapChannels(-> sos.merge(b"a\nb", b"a\r\nb")))  # expects a warning
    _.assertIn(b"a\r\nb", sos.merge(b"a\nb", b"a\r\nb")[0])  # when in doubt, use "mine" CR-LF
    _.assertIn(b"a\nb", sos.merge(b"a\nb", b"a\r\nb", eol = True)[0])
    _.assertEqual(b"\n", sos.merge(b"a\nb", b"a\r\nb", eol = True)[1])

  def testPickyMode(_):
    ''' Confirm that picky mode reset tracked patterns after commits. '''
    sos.offline("trunk", None, ["--picky"])
    changes = sos.changes()
    _.assertEqual(0, len(changes.additions))  # do not list any existing file as an addition
    out:str = wrapChannels(-> sos.add(["."], ["./file?"], options = ["--force", "--relative"]))
    _.assertAllIn(["Added tracking pattern", "'%s'" % "file?", "'.'"], out)
    _.createFile(1, "aa")
    sos.commit("First")  # add one file
    _.assertEqual(2, len(os.listdir(sos.revisionFolder(0, 1))))
    _.createFile(2, "b")
    try: sos.commit("Second")  # add nothing, because picky
    except: pass
    sos.add(["."], ["./file?"])
    sos.commit("Third")
    _.assertEqual(2, len(os.listdir(sos.revisionFolder(0, 2))))
    out = wrapChannels(-> sos.log()).replace("\r", "")
    _.assertIn("    r0", out)
    sys.argv.extend(["-n", "2"])  # We cannot use the opions array for named argument options
    out = wrapChannels(-> sos.log()).replace("\r", "")
    sys.argv.pop(); sys.argv.pop()
    _.assertNotIn("    r0", out)  # because number of log lines was limited by argument
    _.assertIn("    r1", out)
    _.assertIn("  * r2", out)
    try: sos.config(["set", "logLines", "1"], options = ["--local"])
    except SystemExit as E: _.assertEqual(0, E.code)
    out = wrapChannels(-> sos.log([])).replace("\r", "")
    _.assertNotIn("    r0", out)  # because number of log lines was limited
    _.assertNotIn("    r1", out)
    _.assertIn("  * r2", out)
    _.createFile(3, prefix = "sub")
    sos.add(["sub"], ["sub/file?"])
    changes = sos.changes()
    _.assertEqual(1, len(changes.additions))
    _.assertTrue("sub/file3" in changes.additions)

  def testTrackedSubfolder(_):
    ''' See if patterns for files in sub folders are picked up correctly. '''
    os.mkdir("." + os.sep + "sub")
    sos.offline("trunk", None, ["--track"])
    _.createFile(1, "x")
    _.createFile(1, "x", prefix = "sub")
    sos.add(["."], ["./file?"])  # add glob pattern to track
    sos.commit("First")
    _.assertEqual(2, len(os.listdir(sos.revisionFolder(0, 1))))  # one new file + meta file
    sos.add(["."], ["sub/file?"])  # add glob pattern to track
    sos.commit("Second")  # one new file + meta
    _.assertEqual(2, len(os.listdir(sos.revisionFolder(0, 1))))  # one new file + meta file
    os.unlink("file1")  # remove from basefolder
    _.createFile(2, "y")
    sos.remove(["."], ["sub/file?"])
    try: sos.remove(["."], ["sub/bla"]); _.fail("Expected exit")  # TODO check more textual details here
    except SystemExit as E: _.assertEqual(1, E.code)
    sos.commit("Third")
    _.assertEqual(2, len(os.listdir(sos.revisionFolder(0, 2))))  # one new file + meta
    # TODO also check if /file1 and sub/file1 were removed from index

  def testTrackedMode(_):
    ''' Difference in semantics vs simple mode:
          - For remote/other branch we can only know and consider tracked files, thus ignoring all complexity stemming from handling addition of untracked files.
          - For current branch, we can take into account tracked and untracked ones, in theory, but it doesn't make sense.
        In conclusion, using the union of tracking patterns from both sides to find affected files makes sense, but disallow deleting files not present in remote branch.
    '''
    sos.offline("test", options = ["--track"])  # set up repo in tracking mode (SVN- or gitless-style)
    _.createFile(1)
    _.createFile("a123a")  # untracked file "a123a"
    sos.add(["."], ["./file?"])  # add glob tracking pattern
    sos.commit("second")  # versions "file1"
    _.assertEqual(2, len(os.listdir(sos.revisionFolder(0, 1))))  # one new file + meta file
    out:str = wrapChannels(-> sos.status()).replace("\r", "")
    _.assertTrue(any("|" in o and "./file?" in o for o in out.split("\n")))

    _.createFile(2)  # untracked file "file2"
    sos.commit("third")  # versions "file2"
    _.assertEqual(2, len(os.listdir(sos.revisionFolder(0, 2))))  # one new file + meta file

    os.mkdir("." + os.sep + "sub")
    _.createFile(3, prefix = "sub")  # untracked file "sub/file3"
    sos.commit("fourth", ["--force"])  # no tracking pattern matches the subfolder
    _.assertEqual(1, len(os.listdir(sos.revisionFolder(0, 3))))  # meta file only, no other tracked path/file

    sos.branch("Other")  # second branch containing file1 and file2 tracked by "./file?"
    sos.remove(["."], ["./file?"])  # remove tracking pattern, but don't touch previously created and versioned files
    sos.add([".", "."], ["./a*a", "./a*?"])  # add tracking pattern
    changes = sos.changes()  # should pick up addition only, because tracked, but not the deletion, as not tracked anymore
    _.assertEqual(0, len(changes.modifications))
    _.assertEqual(0, len(changes.deletions))  # not tracked anymore, but contained in version history and not removed
    _.assertEqual(1, len(changes.additions))  # detected one addition "a123a", but won't recognize untracking files as deletion

    sos.commit("Second_2")
    _.assertEqual(2, len(os.listdir(sos.revisionFolder(1, 1))))  # "a123a" + meta file
    _.existsFile(1, b"x" * 10)
    _.existsFile(2, b"x" * 10)

    sos.switch("test")  # go back to first branch - tracks only "file?", but not "a*a"
    _.existsFile(1, b"x" * 10)
    _.existsFile("a123a", b"x" * 10)

    sos.update("Other")  # integrate tracked files and tracking pattern from second branch into working state of master branch
    _.assertTrue(os.path.exists("." + os.sep + "file1"))
    _.assertTrue(os.path.exists("." + os.sep + "a123a"))

    _.createFile("axxxa")  # new file that should be tracked on "test" now that we integrated "Other"
    sos.commit("fifth")  # create new revision after integrating updates from second branch
    _.assertEqual(3, len(os.listdir(sos.revisionFolder(0, 4))))  # one new file from other branch + one new in current folder + meta file
    sos.switch("Other")  # switch back to just integrated branch that tracks only "a*a" - shouldn't do anything
    _.assertTrue(os.path.exists("." + os.sep + "file1"))
    _.assertTrue(os.path.exists("." + os.sep + "a123a"))
    _.assertFalse(os.path.exists("." + os.sep + "axxxa"))  # because tracked in both branches, but not present in other -> delete in file tree
    # TODO test switch --meta

  def testLsTracked(_):
    sos.offline("test", options = ["--track"])  # set up repo in tracking mode (SVN- or gitless-style)
    _.createFile(1)
    _.createFile("foo")
    sos.add(["."], ["./file*"])  # capture one file
    sos.ls()
    out:str = sos.safeSplit(wrapChannels(-> sos.ls()).replace("\r", ""), "\n")
    _.assertInAny("TRK file1  (file*)", out)
    _.assertNotInAny("... file1  (file*)", out)
    _.assertInAny("    foo", out)
    out = sos.safeSplit(wrapChannels(-> sos.ls(options = ["--patterns"])).replace("\r", ""), "\n")
    _.assertInAny("TRK file*", out)
    _.createFile("a", prefix = "sub")
    sos.add(["sub"], ["sub/a"])
    sos.ls("sub")
    _.assertInAny("TRK a  (a)", sos.safeSplit(wrapChannels(-> sos.ls("sub")).replace("\r", ""), "\n"))

  def testLineMerge(_):
    _.assertEqual("xabc", sos.lineMerge("xabc", "a bd"))  # integrate all of other into -> mine
    _.assertEqual("xabxxc", sos.lineMerge("xabxxc", "a bd"))
    _.assertEqual("xa bdc", sos.lineMerge("xabc", "a bd", mergeOperation = sos.MergeOperation.INSERT))  # keep old and insert new
    _.assertEqual("ab", sos.lineMerge("xabc", "a bd", mergeOperation = sos.MergeOperation.REMOVE))  # remove old and no change of new

  def testCompression(_):  # TODO test output ratio/advantage, also depending on compress flag set or not
    _.createFile(1)
    sos.offline("master", options = ["--force"])
    out:str = wrapChannels(-> sos.changes(options = ['--progress'])).replace("\r", "").split("\n")
    _.assertFalse(any("Compression advantage" in line for line in out))  # simple mode should always print this to stdout
    _.assertTrue(_.existsFile(sos.revisionFolder(0, 0, file = "b9ee10a87f612e299a6eb208210bc0898092a64c48091327cc2aaeee9b764ffa"), b"x" * 10))
    setRepoFlag("compress", True)  # was plain = uncompressed before
    _.createFile(2)
    out = wrapChannels(-> sos.commit("Added file2", options = ['--progress'])).replace("\r", "").split("\n")
    _.assertTrue(any("Compression advantage" in line for line in out))
    _.assertTrue(_.existsFile(sos.revisionFolder(0, 1, file = "03b69bc801ae11f1ff2a71a50f165996d0ad681b4f822df13329a27e53f0fcd2")))  # exists
    _.assertFalse(_.existsFile(sos.revisionFolder(0, 1, file = "03b69bc801ae11f1ff2a71a50f165996d0ad681b4f822df13329a27e53f0fcd2"), b"x" * 10))  # but is compressed instead

  def testLocalConfig(_):
    sos.offline("bla", options = [])
    try: sos.config(["set", "ignores", "one;two"], options = ["--local"])
    except SystemExit as E: _.assertEqual(0, E.code)
    _.assertTrue(checkRepoFlag("ignores", value = ["one", "two"]))

  def testConfigVariations(_):
    def makeRepo():
      try: os.unlink("file1")
      except: pass
      sos.offline("master", options = ["--force"])
      _.createFile(1)
      sos.commit("Added file1")
    try: sos.config(["set", "strict", "on"])
    except SystemExit as E: _.assertEqual(0, E.code)
    makeRepo()
    _.assertTrue(checkRepoFlag("strict", True))
    try: sos.config(["set", "strict", "off"])
    except SystemExit as E: _.assertEqual(0, E.code)
    makeRepo()
    _.assertTrue(checkRepoFlag("strict", False))
    try: sos.config(["set", "strict", "yes"])
    except SystemExit as E: _.assertEqual(0, E.code)
    makeRepo()
    _.assertTrue(checkRepoFlag("strict", True))
    try: sos.config(["set", "strict", "no"])
    except SystemExit as E: _.assertEqual(0, E.code)
    makeRepo()
    _.assertTrue(checkRepoFlag("strict", False))
    try: sos.config(["set", "strict", "1"])
    except SystemExit as E: _.assertEqual(0, E.code)
    makeRepo()
    _.assertTrue(checkRepoFlag("strict", True))
    try: sos.config(["set", "strict", "0"])
    except SystemExit as E: _.assertEqual(0, E.code)
    makeRepo()
    _.assertTrue(checkRepoFlag("strict", False))
    try: sos.config(["set", "strict", "true"])
    except SystemExit as E: _.assertEqual(0, E.code)
    makeRepo()
    _.assertTrue(checkRepoFlag("strict", True))
    try: sos.config(["set", "strict", "false"])
    except SystemExit as E: _.assertEqual(0, E.code)
    makeRepo()
    _.assertTrue(checkRepoFlag("strict", False))
    try: sos.config(["set", "strict", "enable"])
    except SystemExit as E: _.assertEqual(0, E.code)
    makeRepo()
    _.assertTrue(checkRepoFlag("strict", True))
    try: sos.config(["set", "strict", "disable"])
    except SystemExit as E: _.assertEqual(0, E.code)
    makeRepo()
    _.assertTrue(checkRepoFlag("strict", False))
    try: sos.config(["set", "strict", "enabled"])
    except SystemExit as E: _.assertEqual(0, E.code)
    makeRepo()
    _.assertTrue(checkRepoFlag("strict", True))
    try: sos.config(["set", "strict", "disabled"])
    except SystemExit as E: _.assertEqual(0, E.code)
    makeRepo()
    _.assertTrue(checkRepoFlag("strict", False))
    try: sos.config(["set", "strict", "nope"]); _.fail()
    except SystemExit as E: _.assertEqual(1, E.code)

  def testLsSimple(_):
    _.createFile(1)
    _.createFile("foo")
    _.createFile("ign1")
    _.createFile("ign2")
    _.createFile("bar", prefix = "sub")
    sos.offline("test")  # set up repo in tracking mode (SVN- or gitless-style)
    try: sos.config(["set", "ignores", "ign1"])  # define an ignore pattern. HINT this is stored in a local test folder, not in the real global configuration!
    except SystemExit as E: _.assertEqual(0, E.code)
    try: sos.config(["add", "ignores", "ign2"])  # additional ignore pattern
    except SystemExit as E: _.assertEqual(0, E.code)
    try: sos.config(["set", "ignoresWhitelist", "ign1;ign2"])  # define a list of ignore patterns
    except SystemExit as E: _.assertEqual(0, E.code)
    out:str = wrapChannels(-> sos.config(["show"])).replace("\r", "")
    _.assertAllIn(["             ignores", "[global]", "['ign1', 'ign2']"], out)
    out = wrapChannels(-> sos.config(["show", "ignores"])).replace("\r", "")
    _.assertAllIn(["             ignores", "[global]", "['ign1', 'ign2']"], out)
    out = sos.safeSplit(wrapChannels(-> sos.ls()).replace("\r", ""), "\n")
    _.assertInAny('    file1', out)
    _.assertInAny('    ign1', out)
    _.assertInAny('    ign2', out)
    _.assertNotIn('DIR sub', out)
    _.assertNotIn('    bar', out)
    out = wrapChannels(-> sos.ls(options = ["--recursive"])).replace("\r", "")
    _.assertIn('DIR sub', out)
    _.assertIn('    bar', out)
    try: sos.config(["rm", "foo", "bar"]); _.fail()
    except SystemExit as E: _.assertEqual(1, E.code)
    try: sos.config(["rm", "ignores", "foo"]); _.fail()
    except SystemExit as E: _.assertEqual(1, E.code)
    try: sos.config(["rm", "ignores", "ign1"])
    except SystemExit as E: _.assertEqual(0, E.code)
    try: sos.config(["unset", "ignoresWhitelist"])  # remove ignore pattern
    except SystemExit as E: _.assertEqual(0, E.code)
    out = sos.safeSplit(wrapChannels(-> sos.ls()).replace("\r", ""), "\n")
    _.assertInAny(   '    ign1', out)
    _.assertInAny(   'IGN ign2', out)
    _.assertNotInAny('    ign2', out)

  def testWhitelist(_):
    # TODO test same for simple mode
    _.createFile(1)
    sos.defaults.ignores[:] = ["file*"]  # replace in-place
    sos.offline("xx", options = ["--track", "--strict"])  # because nothing to commit due to ignore pattern
    sos.add(["."], ["./file*"])  # add tracking pattern for "file1"
    sos.commit(options = ["--force"])  # attempt to commit the file
    _.assertEqual(1, len(os.listdir(sos.revisionFolder(0, 1))))  # only meta data, file1 was ignored
    try: sos.online(); _.fail()  # Exit because dirty
    except: pass  # exception expected
    _.createFile("x2")  # add another change
    sos.add(["."], ["./x?"])  # add tracking pattern for "file1"
    try: sos.online(["--force"]); _.fail()  # force beyond dirty flag check
    except: pass
    sos.online(["--force", "--force"])  # force beyond file tree modifications check
    _.assertFalse(os.path.exists(sos.metaFolder))

    _.createFile(1)
    sos.defaults.ignoresWhitelist[:] = ["file*"]
    sos.offline("xx", None, ["--track"])
    sos.add(["."], ["./file*"])
    sos.commit()  # should NOT ask for force here
    _.assertEqual(2, len(os.listdir(sos.revisionFolder(0, 1))))  # meta data and "file1", file1 was whitelisted

  def testRemove(_):
    _.createFile(1, "x" * 100)
    sos.offline("trunk")
    try: sos.destroy("trunk"); _fail()
    except: pass
    _.createFile(2, "y" * 10)
    sos.branch("added")  # creates new branch, writes repo metadata, and therefore creates backup copy
    sos.destroy("trunk")
    _.assertAllIn([sos.metaFile, sos.metaBack, "b0_last", "b1"], os.listdir("." + os.sep + sos.metaFolder))
    _.assertTrue(os.path.exists("." + os.sep + sos.metaFolder + os.sep + "b1"))
    _.assertFalse(os.path.exists("." + os.sep + sos.metaFolder + os.sep + "b0"))
    sos.branch("next")
    _.createFile(3, "y" * 10)  # make a change
    sos.destroy("added", "--force")  # should succeed

  def testFastBranchingOnEmptyHistory(_):
    ''' Test fast branching without revisions and with them. '''
    sos.offline(options = ["--strict", "--compress"])  # b0
    sos.branch("", "", options = ["--fast", "--last"])  # b1
    sos.branch("", "", options = ["--fast", "--last"])  # b2
    sos.branch("", "", options = ["--fast", "--last"])  # b3
    sos.destroy("2")
    out:str = wrapChannels(-> sos.status()).replace("\r", "")
    _.assertIn("b0 'trunk' @", out)
    _.assertIn("b1         @", out)
    _.assertIn("b3         @", out)
    _.assertNotIn("b2         @", out)
    sos.branch("", "")  # non-fast branching of b4
    _.createFile(1)
    _.createFile(2)
    sos.commit("")
    sos.branch("", "", options = ["--fast", "--last"])  # b5
    sos.destroy("4")
    out = wrapChannels(-> sos.status()).replace("\r", "")
    _.assertIn("b0 'trunk' @", out)
    _.assertIn("b1         @", out)
    _.assertIn("b3         @", out)
    _.assertIn("b5         @", out)
    _.assertNotIn("b2         @", out)
    _.assertNotIn("b4         @", out)
    # TODO add more files and branch again

  def testUsage(_):
    try: sos.usage(); _.fail()  # TODO expect sys.exit(0)
    except: pass
    try: sos.usage("help"); _.fail()  # TODO expect sys.exit(0)
    except: pass
    try: sos.usage("help", verbose = True); _.fail()  # TODO expect sys.exit(0)
    except: pass
    try: sos.usage(version = True); _.fail()
    except: pass
    try: sos.usage(version = True); _.fail()
    except: pass

  def testOnlyExcept(_):
    ''' Test blacklist glob rules. '''
    sos.offline(options = ["--track"])
    _.createFile("a.1")
    _.createFile("a.2")
    _.createFile("b.1")
    _.createFile("b.2")
    sos.add(["."], ["./a.?"])
    sos.add(["."], ["./?.1"], negative = True)
    out:str = wrapChannels(-> sos.commit())
    _.assertIn("ADD ./a.2", out)
    _.assertNotIn("ADD ./a.1", out)
    _.assertNotIn("ADD ./b.1", out)
    _.assertNotIn("ADD ./b.2", out)

  def testOnly(_):
    _.assertEqual((f{"./A", "x/B"}, f{"./C"}, ["bla"], ["blo"]), tuple([r if i < 2 else [os.path.basename(x) for x in r] for i, r in enumerate(sos.parseArgumentOptions(".", ["abc", "def", "--only", "A", "--x", "--only", "x/B", "--except", "C", "--remote", "bla", "--exclude-remote", "blo", "--only"]))]))
    _.assertEqual(f{"B"}, sos.conditionalIntersection(f{"A", "B", "C"}, f{"B", "D"}))
    _.assertEqual(f{"B", "D"}, sos.conditionalIntersection(f{}, f{"B", "D"}))
    _.assertEqual(f{"B", "D"}, sos.conditionalIntersection(None, f{"B", "D"}))
    sos.offline(options = ["--track", "--strict"])
    _.createFile(1)
    _.createFile(2)
    sos.add(["."], ["./file1"])
    sos.add(["."], ["./file2"])
    sos.commit(onlys = f{"./file1"})
    _.assertEqual(2, len(os.listdir(sos.revisionFolder(0, 1))))  # only meta and file1
    sos.commit()  # adds also file2
    _.assertEqual(2, len(os.listdir(sos.revisionFolder(0, 2))))  # only meta and file1
    _.createFile(1, "cc")  # modify both files
    _.createFile(2, "dd")
    try: sos.config(["set", "texttype", "file2"])
    except SystemExit as E: _.assertEqual(0, E.code)
    changes = sos.changes(excps = f{"./file1"})
    _.assertEqual(1, len(changes.modifications))  # only file2
    _.assertTrue("./file2" in changes.modifications)
    _.assertAllIn(["DIF ./file2", "<No newline>"], wrapChannels(-> sos.diff("/", onlys = f{"./file2"})))
    _.assertAllNotIn(["MOD ./file1", "DIF ./file1", "MOD ./file2"], wrapChannels(-> sos.diff("/", onlys = f{"./file2"})))  # MOD vs. DIF
    _.assertIn("MOD ./file1", wrapChannels(-> sos.diff("/", excps = f{"./file2"})))  # MOD vs. DIF
    _.assertNotIn("MOD ./file2", wrapChannels(-> sos.diff("/", excps = f{"./file2"})))

  def testEmptyFiles(_):
    sos.offline()
    _.createFile(1, "")  # empty file
    sos.commit()
    changes = sos.changes()
    _.assertEqual(0, len(changes.additions) + len(changes.modifications) + len(changes.deletions))

    setRepoFlag("strict", True)
    changes = sos.changes()
    _.assertEqual(1, len(changes.modifications))  # because hash was set to None in simple mode
    sos.commit()  # commit now with hash computation
    setRepoFlag("strict", False)

    time.sleep(FS_PRECISION)
    _.createFile(1, "")  # touch file
    changes = sos.changes()
    _.assertEqual(1, len(changes.modifications))  # since modified timestamp

  def testDiff(_):
    try: sos.config(["set", "texttype", "file1"])  # manually mark this file as "textual"
    except SystemExit as E: _.assertEqual(0, E.code)
    sos.offline(options = ["--strict"])
    _.createFile(1)
    _.createFile(2)
    sos.commit()
    _.createFile(1, "sdfsdgfsdf")
    _.createFile(2, "12343")
    sos.commit()
    _.createFile(1, "foobar")
    _.createFile(3)
    out:str = wrapChannels(-> sos.diff("/-2"))  # compare with r1 (second counting from last which is r2)
    _.assertIn("ADD ./file3", out)
    _.assertAllIn(["MOD ./file2", "DIF ./file1  <No newline>", "old 0 |xxxxxxxxxx|", "now 0 |foobar|"], out)
    _.assertAllNotIn(["MOD ./file1", "DIF ./file1"], wrapChannels(-> sos.diff("/-2", onlys = f{"./file2"})))

  def testReorderRenameActions(_):
    result:Tuple[str,str] = sos.reorderRenameActions([("123", "312"), ("312", "132"), ("321", "123")], exitOnConflict = False)
    _.assertEqual([("312", "132"), ("123", "312"), ("321", "123")], result)
    try: sos.reorderRenameActions([("123", "312"), ("312", "123")], exitOnConflict = True); _.fail()
    except: pass

  def testPublish(_):
    pass  # TODO how to test without modifying anything underlying? probably use --test flag or similar?

  def testColorFlag(_):
    sos.offline()
    _.createFile(1)
#    setRepoFlag("useColorOutput", False, toConfig = True)
#    sos.Metadata.singleton = None  # for new slurp of configuration
    sos.enableColor(False, force = True)
    sos.verbose[:] = [None]  # set "true"
    out:List[str] = wrapChannels(-> sos.changes()).replace("\r\n", "\n").split("\n")
    _.assertTrue(any(line.startswith(sos.usage.MARKER_TEXT + "Changes of file tree") for line in out))
#    setRepoFlag("useColorOutput", True,  toConfig = True)
#    sos.Metadata.singleton = None
    sos.enableColor(True, force = True)
    out = wrapChannels(-> sos.changes()).replace("\r\n", "\n").split("\n")
    _.assertTrue(any(line.startswith((sos.usage.MARKER_TEXT if sys.platform == "win32" else sos.MARKER_COLOR) + "Changes of file tree") for line in out))  # because it may start with a color code
    sos.verbose.pop()

  def testMove(_):
    ''' Move primarily modifies tracking patterns and moves files around accordingly. '''
    sos.offline(options = ["--strict", "--track"])
    _.createFile(1)
    sos.add(["."], ["./file?"])
    # assert error when source folder is missing
    out:str = wrapChannels(-> sos.move("sub", "sub/file?", ".", "./?file"))
    _.assertIn("Source folder doesn't exist", out)
    _.assertIn("EXIT CODE 1", out)
    # if target folder missing: create it and move matching files into it
    sos.move(".", "./file?", "sub", "sub/file?")
    _.assertTrue(os.path.exists("sub"))
    _.assertTrue(os.path.exists("sub/file1"))
    _.assertFalse(os.path.exists("file1"))
    # test move back to previous location, plus rename the file
    sos.move("sub", "sub/file?", ".", "./?file")
    _.assertTrue(os.path.exists("1file"))
    _.assertFalse(os.path.exists("sub/file1"))
    # assert error when nothing matches source pattern
    out = wrapChannels(-> sos.move(".", "./a*", ".", "./b*"))
    _.assertIn("No files match the specified file pattern", out)
    _.assertIn("EXIT CODE", out)
    sos.add(["."], ["./*"])  # add catch-all tracking pattern to root folder
    out = wrapChannels(-> sos.move(".", "./a*", ".", "./b*", options = ["--force"]))
    _.assertIn("  './*' matches 3 files", out)
    _.assertIn("EXIT CODE", out)
    # test rename no conflict
    _.createFile(1)
    _.createFile(2)
    _.createFile(3)
    sos.add(["."], ["./file*"])
    sos.remove(["."], ["./*"])
    try: sos.config(["set", "ignores", "file3;file4"])  # define an ignore pattern
    except SystemExit as E: _.assertEqual(0, E.code)
    try: sos.config(["set", "ignoresWhitelist", "file3"])
    except SystemExit as E: _.assertEqual(0, E.code)
    sos.move(".", "./file*", ".", "./fi*le")  # should only move not ignored files files
    _.assertTrue(all(os.path.exists("fi%dle" % i) for i in range(1, 4)))
    _.assertTrue(all(not os.path.exists("file%d" % i) for i in range(1, 4)))
    _.assertFalse(os.path.exists("fi4le"))
    # test rename solvable conflicts
    [_.createFile("%s-%s-%s" % tuple(c for c in n)) for n in ["312", "321", "123", "231"]]
#    sos.move("?-?-?")
    # test rename unsolvable conflicts
    # test --soft option
    sos.remove(["."], ["./?file"])  # untrack pattern, which was renamed before
    sos.add(["."], ["./?a?b"], ["--force"])
    sos.move(".", "./?a?b", ".", "./a?b?", ["--force", "--soft"])
    _.createFile("1a2b")  # should not be tracked
    _.createFile("a1b2")  # should be tracked
    sos.commit()
    _.assertEqual(5, len(os.listdir(sos.revisionFolder(0, 1))))  # meta, a1b2, fi[1-3]le
    _.assertTrue(os.path.exists(sos.revisionFolder(0, 1, file = "93b38f90892eb5c57779ca9c0b6fbdf6774daeee3342f56f3e78eb2fe5336c50")))  # a1b2
    _.createFile("1a1b1")
    _.createFile("1a1b2")
    sos.add(["."], ["./?a?b*"])
    # test target pattern exists
    out = wrapChannels(-> sos.move(".", "./?a?b*", ".", "./z?z?"))
    _.assertIn("not unique", out)
    # TODO only rename if actually any files are versioned? or simply what is currently alife?
    # TODO add test if two single question marks will be moved into adjacent characters

  def testAskUpdate(_):
    _.createFile(1)
    _.createFile(3)
    _.createFile(5)
    sos.offline()  # branch 0: only file1
    sos.branch()
    os.unlink("file1")
    os.unlink("file3")
    os.unlink("file5")
    _.createFile(2)
    _.createFile(4)
    _.createFile(6)
    sos.commit()  # branch 1: only file2
    sos.switch("0/")
    mockInput(["y", "a", "y", "a"], -> sos.update("1/", ["--ask"]))
    _.assertFalse(_.existsFile(1))
    _.assertFalse(_.existsFile(3))
    _.assertFalse(_.existsFile(5))
    _.assertTrue(_.existsFile(2))
    _.assertTrue(_.existsFile(4))
    _.assertTrue(_.existsFile(6))

  def testMoveDetection(_):
    _.createFile(1, "bla")
    sos.offline()
    os.mkdir("sub1")
    os.mkdir("sub2")
    shutil.copy2("file1", "sub1" + os.sep + "file_I")
    shutil.move("file1", "sub2")
    out:str = wrapChannels(-> sos.changes())
    _.assertIn("MOV sub2/file1  <-  ./file1", out)  # ensure that the correctly named while is detected as a move,
    _.assertIn("ADD sub1/file_I", out)  # while the differently named (same file) is detected as added
    sos.commit("Moved the file")
#    out = wrapChannels(-> sos.log(["--changes"]))  # TODO moves detection not yet implemented
#    _.assertIn("MOV sub2/file1  <-  ./file1", out)  # ensure that the correctly named while is detected as a move,
#    _.assertIn("ADD sub1/file_I", out)  # while the differently named (same file) is detected as added
    _.createFile(1, "bla", prefix = "sub")

  def testHashCollision(_):
    old = sos.Metadata.findChanges
    def patched(_, branch:int? = None, revision:int? = None, checkContent:bool = False, inverse:bool = False, considerOnly:FrozenSet[str]? = None, dontConsider:FrozenSet[str]? = None, progress:bool = False, remotes:List[str] = []) -> Tuple[sos.ChangeSet,str?] =
      import collections  # used only in this method
      write = branch is not None and revision is not None
      if write:
        try: os.makedirs(sos.encode(sos.revisionFolder(branch, revision, base = _.root)))
        except FileExistsError: pass  # HINT "try" only necessary for hash collision *test code* (!)
      old(_, branch, revision, checkContent, inverse, considerOnly, dontConsider, progress)
    sos.Metadata.findChanges = patched  # monkey-patch
    sos.offline()
    _.createFile(1)
    os.mkdir(sos.revisionFolder(0, 1))
    _.createFile("b9ee10a87f612e299a6eb208210bc0898092a64c48091327cc2aaeee9b764ffa", prefix = sos.revisionFolder(0, 1))  # hashed file name for not-yet-committed file1
    _.createFile(1)
    try: sos.commit(); _.fail("Expected system exit due to hash collision detection")
    except SystemExit as E: _.assertEqual(1, E.code)  # HINT exit is implemented in utility.hashFile
    sos.Metadata.findChanges = old  # revert monkey patch

  def testFindBase(_):
    old = os.getcwd()
    try:
        os.mkdir("." + os.sep + ".git")
        os.makedirs("." + os.sep + "a" + os.sep + sos.metaFolder)
        os.makedirs("." + os.sep + "a" + os.sep + "b")
        os.chdir("a" + os.sep + "b")
        s, vcs, cmd = sos.findSosVcsBase()
        _.assertIsNotNone(s)
        _.assertIsNotNone(vcs)
        _.assertEqual("git", cmd)
    finally: os.chdir(old)

  # TODO test command line operation --sos vs. --vcs
  # check exact output instead of only expected exception/fail

  # TODO test +++ --- in diff
  # TODO test +01/-02/*..
  # TODO tests for loadcommit redirection
  # TODO test wrong branch/revision after fast branching, would raise exception for -1 otherwise

def load_tests(loader, tests, ignore) =
  ''' Python unittest by-convention test definition. '''
  tests.addTests(doctest.DocTestSuite("sos.pure", optionflags = doctest.ELLIPSIS | doctest.REPORT_NDIFF | doctest.NORMALIZE_WHITESPACE))
  tests.addTests(doctest.DocTestSuite("sos.utility", optionflags = doctest.ELLIPSIS | doctest.REPORT_NDIFF | doctest.NORMALIZE_WHITESPACE))
  tests


if __name__ == '__main__':
  logging.basicConfig(level = logging.DEBUG, stream = sys.stderr, format = "%(asctime)-23s %(levelname)-8s %(name)s:%(lineno)d | %(message)s" if '--log' in sys.argv else "%(message)s")
  unittest.main(testRunner = debugTestRunner() if '-v' in sys.argv and not os.getenv("CI", "false").lower() == "true" else None)  # warnings = "ignore")
